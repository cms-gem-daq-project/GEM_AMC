<?xml version="1.0" encoding="ISO-8859-1"?>
<!--  The tags attribute is a free test attribute which meaning is defined by the uHAL user -->
  <node id='GEM_AMC' xmlns:xi="http://www.w3.org/2001/XInclude">

    <!--TTC module -->
    <node id="TTC"  address="0x00300000"
          description="TTC control and monitoring. It takes care of locking to the TTC clock coming from the
                       backplane as well as decoding TTC commands and forwarding that to all other modules in
                       the design. It also provides several control and monitoring registers (resets, command
                       decoding configuration, clock and data status, bc0 status, command counters and a small spy buffer)"
          fw_is_module="true"
          fw_module_file="../common/hdl/ttc/ttc.vhd"
          fw_user_clock_signal="ttc_clks_i.clk_40"
          fw_bus_clock_signal="ipb_clk_i"
          fw_bus_reset_signal="ipb_reset_i"
          fw_master_bus_signal="ipb_mosi_i"
          fw_slave_bus_signal="ipb_miso_o"
          fw_reg_addr_msb="7"
          fw_reg_addr_lsb="0">
      <node id="CTRL" address="0x0"
            description="TTC control">
        <node id="MODULE_RESET" address="0x0" permission="w"
              description="TTC module reset"
              fw_write_pulse_signal="ttc_ctrl.reset_local"/>
        <node id="MMCM_RESET" address="0x1" permission="w"
              description="Main MMCM reset. Note that resetting this MMCM normally shouldn't be needed.
                           It may screw up the fiber links, requiring a GTH reset.
                           This will also re-initiate the phase alignment procedure.
                           In case of doubt, always try the phase alignment reset first, before resorting to MMCM reset."
              fw_write_pulse_signal="ttc_ctrl.clk_ctrl.reset_mmcm"/>
        <node id="CNT_RESET" address="0x2" permission="w"
              description="TTC counter reset"
              fw_write_pulse_signal="ttc_ctrl.cnt_reset"
              sw_ctrl_configure_set="0x1" sw_ctrl_start_set="0x1"/>
        <node id="PHASE_ALIGNMENT_RESET" address="0x3" permission="w"
              description="This will restart the procedure of aligning the main jitter cleaned clock to the backplane TTC ref clock.
                           It may or may not screw up the fiber links (needs testing), and if it does, a GTH reset should help."
              fw_write_pulse_signal="ttc_ctrl.clk_ctrl.reset_sync_fsm"/>
        <node id="L1A_ENABLE" address="0x4" mask="0x00000001" permission="rw"
              description="Enable L1As (L1As are blocked if this is 0)"
              fw_signal="ttc_ctrl.l1a_enable" fw_default="0b1"
              sw_ctrl_configure_set="0x0" sw_ctrl_start_set="0x1" sw_ctrl_stop_set="0x0"/>
        <node id="CALIBRATION_MODE" address="0x4" mask="0x00000002" permission="rw"
              description="Enables calibration mode when set to 1. In calibration mode the incoming L1A commands will trigger a calpulse signal to the frontend in addition to the L1A.
                           Note: the L1A delay below does not affect the calpulse timing, but it does shift the L1A that is sent to the frontend (typically the delay will be needed when using calibration mode)."
              fw_signal="ttc_ctrl.calib_mode" fw_default="0b0"
              sw_ctrl_configure_set="0x0" sw_ctrl_start_set="0x0" sw_ctrl_stop_set="0x0"/>
        <node id="L1A_DELAY" address="0x4" mask="0x3ff00000" permission="rw"
              description="Setting this to non-zero value will delay the L1A delivery to the frontend (this is useful in calibration mode to separate the L1A from the calpulse in time)"
              fw_signal="ttc_ctrl.l1a_delay" fw_default="0b0000000000"/>
        <node id="DISABLE_PHASE_ALIGNMENT" address="0x4" mask="0x00000010" permission="rw"
              description="Setting this to 1 will disable the phase alignment to backplane ref clock.
                           This is intended to be used only in setups that don't have an AMC13 and thus no backplane TTC clock, but generate the TTC clock internally in CTP7."
              fw_signal="ttc_ctrl.clk_ctrl.phase_align_disable" fw_default="0b0"/>
        <node id="PA_DISABLE_INIT_SHIFT_OUT" address="0x4" mask="0x00000020" permission="rw"
              description="If this is set to 0 (default), then when the phase alignment FSM is reset,
                           it will first shift the phase out of lock if it is currently locked,
                           and then start searching for lock as usual"
              fw_signal="ttc_ctrl.clk_ctrl.pa_no_init_shift_out" fw_default="0b0"/>
        <node id="PA_MANUAL_OVERRIDE" address="0x4" mask="0x00000040" permission="rw"
              description="Manual phase shifting override"
              fw_signal="ttc_ctrl.clk_ctrl.pa_manual_shift_ovrd" fw_default="0b0"/>
        <node id="PA_MANUAL_SHIFT_DIR" address="0x4" mask="0x00000080" permission="rw"
              description="Manual phase shifting direction"
              fw_signal="ttc_ctrl.clk_ctrl.pa_manual_shift_dir" fw_default="0b0"/>
        <node id="PA_MANUAL_SHIFT_EN" address="0x5" permission="w"
              description="Each write to this register will trigger one shift step when PA_MANUAL_OVERRIDE is set to 1"
              fw_write_pulse_signal="ttc_ctrl.clk_ctrl.pa_manual_shift_en"/>
        <node id="PHASEMON_MMCM_RESET" address="0x6" permission="w"
              description="Resets the phase monitor clock MMCMs."
              fw_write_pulse_signal="ttc_ctrl.clk_ctrl.reset_phase_mon_mmcm"/>
        <node id="PHASEMON_LOG2_N_AVG" address="0x4" mask="0x00000f00" permission="rw"
              description="Number of samples to average in the phase monitor. The setting is in units of log2(n), meaning that e.g. a setting of 4 will result in averaging 16 samples, a setting of 5 will average 32 samples, etc"
              fw_signal="ttc_ctrl.clk_ctrl.phase_mon_log2_navg" fw_default="0x5"/>
        <node id="PHASEMON_JUMP_THRESH" address="0x7" mask="0x0000ffff" permission="rw"
              description="The threshold on the difference of the two consecutive phase samples that is considered a phase jump (default = 1.5ns). These occurences are counted and reported through the PHASE_JUMP_CNT reg"
              fw_signal="ttc_ctrl.clk_ctrl.phase_mon_jump_thresh" fw_default="0x0aeb"/>
        <node id="LOCKMON_LOG2_N_AVG" address="0x7" mask="0x000f0000" permission="rw"
              description="Phase lock monitor (used in phase alignment): Number of phase samples to average. The setting is in units of log2(n), meaning that e.g. a setting of 4 will result in averaging 16 samples, a setting of 5 will average 32 samples, etc. The higher the number, the better the accuracy, but it will also take longer to complete the phase alignment."
              fw_signal="ttc_ctrl.clk_ctrl.lock_mon_log2_navg" fw_default="0x7"/>
        <node id="LOCKMON_TARGET_PHASE" address="0x8" mask="0x0000ffff" permission="rw"
              description="Phase lock monitor (used in phase alignment): the target phase between the TTC clock and the fabric clocks that is considered locked. The units are the same as in the phase monitor. NOTE: do not set this at or close to 0 or the maximum phase -- this could result in unreliable phase alignment, it should be placed at least 1ns away from the 0/max rollover point."
              fw_signal="ttc_ctrl.clk_ctrl.lock_mon_target_phase" fw_default="0x2f1a"/>
        <node id="LOCKMON_TOLLERANCE" address="0x8" mask="0xffff0000" permission="rw"
              description="Phase lock monitor (used in phase alignment): this is the half-size of the lock window, or the number of phase units plus/minus the target (LOCKMON_TARGET_PHASE) where the phase is considered locked"
              fw_signal="ttc_ctrl.clk_ctrl.lock_mon_tollerance" fw_default="0x0035"/>
      </node>
      <node id="CONFIG" address="0x10"
            description="TTC configuration -- used for setup TTC command decoding">
        <node id="CMD_BC0" address="0x0" mask="0x000000ff" permission="rw"
              description="BC0 command code"
              fw_signal="ttc_conf.cmd_bc0" fw_default="0x01"
              sw_ctrl_configure_confdb_check_set="true"/>
        <node id="CMD_EC0" address="0x0" mask="0x0000ff00" permission="rw"
              description="EC0 command code"
              fw_signal="ttc_conf.cmd_ec0" fw_default="0x02"
              sw_ctrl_configure_confdb_check_set="true"/>
        <node id="CMD_RESYNC" address="0x0" mask="0x00ff0000" permission="rw"
              description="Resync command code"
              fw_signal="ttc_conf.cmd_resync" fw_default="0x04"
              sw_ctrl_configure_confdb_check_set="true"/>
        <node id="CMD_OC0" address="0x0" mask="0xff000000" permission="rw"
              description="OC0 command code"
              fw_signal="ttc_conf.cmd_oc0" fw_default="0x08"
              sw_ctrl_configure_confdb_check_set="true"/>
        <node id="CMD_HARD_RESET" address="0x1" mask="0x000000ff" permission="rw"
              description="Hard-reset command code"
              fw_signal="ttc_conf.cmd_hard_reset" fw_default="0x10"
              sw_ctrl_configure_confdb_check_set="true"/>
        <node id="CMD_CALPULSE" address="0x1" mask="0x0000ff00" permission="rw"
              description="Calibration pulse command code"
              fw_signal="ttc_conf.cmd_calpulse" fw_default="0x14"
              sw_ctrl_configure_confdb_check_set="true"/>
        <node id="CMD_START" address="0x1" mask="0x00ff0000" permission="rw"
              description="START command code"
              fw_signal="ttc_conf.cmd_start" fw_default="0x18"
              sw_ctrl_configure_confdb_check_set="true"/>
        <node id="CMD_STOP" address="0x1" mask="0xff000000" permission="rw"
              description="STOP command code"
              fw_signal="ttc_conf.cmd_stop" fw_default="0x1c"
              sw_ctrl_configure_confdb_check_set="true"/>
        <node id="CMD_TEST_SYNC" address="0x2" mask="0x000000ff" permission="rw"
              description="Test-sync command code"
              fw_signal="ttc_conf.cmd_test_sync" fw_default="0x20"
              sw_ctrl_configure_confdb_check_set="true"/>
      </node>

      <node id="STATUS" address="0x20"
            description="TTC status">

        <node id="CLK" address="0x0"
              description="Clock status">
          <node id="MMCM_LOCKED" address="0x0" mask="0x00000001" permission="r"
                description="Main MMCM lock status (input is jitter cleaned 160MHz clock)"
                fw_signal="ttc_clks_status_i.mmcm_locked"
                sw_monitor_error_value="0"/>
          <node id="SYNC_DONE" address="0x0" mask="0x00000002" permission="r"
                description="Jitter cleaned clock is locked and phase alignment with backplane TTC ref clock is finished"
                fw_signal="ttc_clks_status_i.sync_done"
                sw_monitor_error_value="0"/>
          <node id="PHASE_LOCKED" address="0x0" mask="0x00000004" permission="r"
                description="Jitter cleaned 40MHz clock is currently in phase with the backplane 40MHz TTC clock"
                fw_signal="ttc_clks_status_i.phase_locked"
                sw_monitor_error_value="0"/>
          <node id="PHASEMON_MMCM_LOCKED" address="0x0" mask="0x00000008" permission="r"
                description="The phase measurement MMCM is locked (DMTD clock)"
                fw_signal="ttc_clks_status_i.phasemon_mmcm_locked"
                sw_monitor_error_value="0"/>
          <node id="TTC_CLK_PRESENT" address="0x0" mask="0x00000010" permission="r"
                description="Indicates whether or not the backplane 40MHz TTC clock is present."
                fw_signal="ttc_clks_status_i.ttc_clk_present"
                sw_monitor_error_value="0"/>
          <node id="MMCM_UNLOCK_CNT" address="0x0" mask="0xffff0000" permission="r"
                description="Number of times the MMCM lock signal has gone low (this counter doesn't roll over)"
                fw_signal="ttc_clks_status_i.mmcm_unlock_cnt"
                sw_monitor_warn_min_threshold="1"/>
          <node id="TTC_CLK_LOSS_CNT" address="0x1" mask="0x0000ffff" permission="r"
                description="number of times that the TTC clock was lost (the TTC_CLK_PRESENT has gone low)"
                fw_signal="ttc_clks_status_i.ttc_clk_loss_cnt"
                sw_monitor_warn_min_threshold="1"/>
          <node id="PHASE_UNLOCK_CNT" address="0x1" mask="0xffff0000" permission="r"
                description="Number of times the phase monitoring PLL lock signal has gone low (note: loosing phase lock doesn't restart the phase alignment automatically)"
                fw_signal="ttc_clks_status_i.phase_unlock_cnt"
                sw_monitor_warn_min_threshold="1"/>
          <node id="SYNC_DONE_TIME" address="0x2" mask="0x0000ffff" permission="r"
                description="Number of seconds since last sync was done (max = around 18.2 hours)"
                fw_signal="ttc_clks_status_i.sync_done_time"/>
          <node id="PHASE_UNLOCK_TIME" address="0x2" mask="0xffff0000" permission="r"
                description="Number of seconds since last phase unlock (max = around 18.2 hours)"
                fw_signal="ttc_clks_status_i.phase_unlock_time"/>
          <node id="TTC_CLK_LOSS_TIME" address="0x3" mask="0x0000ffff" permission="r"
                description="number of seconds since last TTC clock loss"
                fw_signal="ttc_clks_status_i.ttc_clk_loss_time"/>

          <node id="PHASE_MONITOR" address="0x6" description="Monitoring of the phase between the TTC backplane clock, and the fabric clocks">
              <node id="PHASE" address="0x0" mask="0x0000ffff" permission="r"
                    description="TTC Phase monitoring: phase difference between the rising edges of the jitter cleaned 40MHz and backplane TTC 40MHz clocks.
                                 Each count is about 1.8633ps (1/13417 of the 25ns period)
                                 Note that absolute value is not very important, because these clocks will always have some offset due to routing on the FPGA,
                                 the important thing is that this value doesn't change much."
                    fw_signal="ttc_clks_status_i.phase_monitor.phase"/>
              <node id="SAMPLE_COUNTER" address="0x0" mask="0xffff0000" permission="r"
                    description="simple wrapping counter of samples - this can be used by fast reading applications to check if the phase value has been updated since the last reading"
                    fw_signal="ttc_clks_status_i.phase_monitor.sample_counter"/>
              <node id="PHASE_MIN" address="0x1" mask="0x0000ffff" permission="r"
                    description="TTC Phase monitoring: the minimum measured phase value since last counter reset"
                    fw_signal="ttc_clks_status_i.phase_monitor.phase_min"/>
              <node id="PHASE_MAX" address="0x1" mask="0xffff0000" permission="r"
                    description="TTC Phase monitoring: the maximum measured phase value since last counter reset"
                    fw_signal="ttc_clks_status_i.phase_monitor.phase_max"/>
              <node id="PHASE_JUMP_CNT" address="0x2" mask="0x0000ffff" permission="r"
                    description="TTC Phase monitoring: number of times a phase jump has been detected.
                                 A phase jump detection is triggered by a large difference between two subsequent phase measurements
                                 (threshold is set by the PHASE_MONITOR_JUMP_THRESH register)"
                    fw_signal="ttc_clks_status_i.phase_monitor.phase_jump_cnt"/>
          </node>

        </node>

        <node id="TTC_SINGLE_ERROR_CNT" address="0x20" mask="0x0000ffff" permission="r"
              description="TTC stream single bit error count"
              fw_signal="ttc_status.single_err"
              sw_monitor_warn_min_threshold="1"/>
        <node id="TTC_DOUBLE_ERROR_CNT" address="0x20" mask="0xffff0000" permission="r"
              description="TTC stream double bit error count"
              fw_signal="ttc_status.double_err"
              sw_monitor_error_min_threshold="1"/>
        <node id="BC0" address="0x21"
              description="TTC status">
          <node id="LOCKED" address="0x0" mask="0x00000001" permission="r"
                description="BC0 locked flag"
                fw_signal="ttc_status.bc0_status.locked"
                sw_monitor_error_value="0"/>
          <node id="UNLOCK_CNT" address="0x1" mask="0x0000ffff" permission="r"
                description="BC0 unlock count"
                fw_signal="ttc_status.bc0_status.unlocked_cnt"
                sw_monitor_error_min_threshold="1"/>
          <node id="OVERFLOW_CNT" address="0x2" mask="0x0000ffff" permission="r"
                description="BX counter overflow count (late or no BC0 received)"
                fw_signal="ttc_status.bc0_status.ovf_cnt"
                sw_monitor_error_min_threshold="1"/>
          <node id="UNDERFLOW_CNT" address="0x2" mask="0xffff0000" permission="r"
                description="BX counter underflow count (early BC0 received, one is normal after the
                             TTC module reset, but this should be reset by control software before each run)"
                fw_signal="ttc_status.bc0_status.udf_cnt"
                sw_monitor_error_min_threshold="1"/>
        </node>        
      </node>

      <node id="CMD_COUNTERS" address="0x50"
            description="TTC command counters">
        <node id="L1A" address="0x0" permission="r"
              description="L1A count"
              fw_signal="ttc_cmds_cnt_arr(0)"/>
        <node id="BC0" address="0x1" permission="r"
              description="BC0 count"
              fw_signal="ttc_cmds_cnt_arr(1)"/>
        <node id="EC0" address="0x2" permission="r"
              description="EC0 count"
              fw_signal="ttc_cmds_cnt_arr(2)"/>
        <node id="RESYNC" address="0x3" permission="r"
              description="Resync count"
              fw_signal="ttc_cmds_cnt_arr(3)"/>
        <node id="OC0" address="0x4" permission="r"
              description="OC0 count"
              fw_signal="ttc_cmds_cnt_arr(4)"/>
        <node id="HARD_RESET" address="0x5" permission="r"
              description="Hard-reset count"
              fw_signal="ttc_cmds_cnt_arr(5)"/>
        <node id="CALPULSE" address="0x6" permission="r"
              description="Calibration pulse count"
              fw_signal="ttc_cmds_cnt_arr(6)"/>
        <node id="START" address="0x7" permission="r"
              description="START count"
              fw_signal="ttc_cmds_cnt_arr(7)"/>
        <node id="STOP" address="0x8" permission="r"
              description="STOP count"
              fw_signal="ttc_cmds_cnt_arr(8)"/>
        <node id="TEST_SYNC" address="0x9" permission="r"
              description="Test-sync count"
              fw_signal="ttc_cmds_cnt_arr(9)"/>
      </node>

      <node id="L1A_ID" address="0x60" mask="0x00ffffff" permission="r"
            description="L1A ID (increments with every L1A and resets with EC0), used by DAQ to tag event numbers"
            fw_signal="l1id_cnt"/>

      <node id="L1A_RATE" address="0x61" permission="r"
            description="L1A rate in Hz"
            fw_signal="l1a_rate"/>

      <node id="TTC_SPY_BUFFER" address="0x62" permission="r"
            description="TTC Spy buffer -- this is filled with TTC commands (from LSB to MSB)
                         and freezes until the user reads it out, once read out it resets and
                         fills up again with new TTC commands received from that point on"
            fw_signal="ttc_spy_buffer" fw_read_pulse_signal="ttc_spy_reset"/>
            
      <node id="GENERATOR" address="0x70"
            description="TTC generator that can be used to generate fake single and cyclic commands that may be useful for calibration">
        <node id="RESET" address="0x0" permission="w"
              description="TTC generator module reset"
              fw_write_pulse_signal="gen_reset"/>
        <node id="ENABLE" address="0x1" mask="0x00000001" permission="rw"
              description="Enable TTC generator module. Note that all real TTC commands are suppressed when the generator module is enabled"
              fw_signal="gen_enable" fw_default="0b0"
              sw_ctrl_configure_set="0x0"/>
        <node id="ENABLE_CALPULSE_ONLY" address="0x1" mask="0x00000004" permission="rw"
              description="Enable TTC generator calpulse signal only. Having ENABLE = 0 and ENABLE_CALPULSE_ONLY = 1 will result in using all TTC commands from AMC13 except calpulse, which will be taken from the generator. This is a debugging feature used for synthetic tests which can emulate data coming from the VFATs. If the ENABLE is set to 1, then this register is ignored, and all TTC commands will be taken from the generator."
              fw_signal="gen_enable_cal_only" fw_default="0b0"
              sw_ctrl_configure_set="0x0"/>
        <node id="SINGLE_HARD_RESET" address="0x2" permission="w"
              description="Writing to this register will trigger a single hard-reset command to be sent"
              fw_write_pulse_signal="gen_single_hard_reset"/>
        <node id="SINGLE_RESYNC" address="0x3" permission="w"
              description="Writing to this register will trigger a single resync command to be sent"
              fw_write_pulse_signal="gen_single_resync"/>
        <node id="SINGLE_EC0" address="0x4" permission="w"
              description="Writing to this register will trigger a single EC0 command to be sent"
              fw_write_pulse_signal="gen_single_ec0"/>
        <node id="CYCLIC_L1A_GAP" address="0x1" mask="0x000ffff0" permission="rw"
              description="This register lets you set the number of BXs between cyclic L1A commands"
              fw_signal="gen_cyclic_l1a_gap" fw_default="0x0190"/>
        <node id="CYCLIC_CALPULSE_TO_L1A_GAP" address="0x1" mask="0xfff00000" permission="rw"
              description="This register lets you set the number of BXs between the cyclic CalPulse and the following L1A. Setting this to 0 will disable the cyclic CalPulse"
              fw_signal="gen_cyclic_cal_l1a_gap" fw_default="0x000"/>
        <node id="CYCLIC_CALPULSE_PRESCALE" address="0x7" mask="0x00000fff" permission="rw"
              description="This register lets you prescale the calpulse in relation to L1A. A value of 0 means that there will be a calpulse before every L1A (if the CYCLIC_CALPULSE_TO_L1A_GAP is more than 0) while e.g. a value of 100 means that there will be a calpulse before every 100th L1A."
              fw_signal="gen_cyclic_cal_prescale" fw_default="0x000"/>
        <node id="CYCLIC_L1A_COUNT" address="0x5" mask="0x00ffffff" permission="rw"
              description="This register lets you set the number of cyclic L1As (and calpulses) to be sent uppon cyclic-start command. If this is set to 0 then cyclic L1As will be sent forever uppon cyclic-start command and can only be stopped with a reset or disabling the generator module."
              fw_signal="gen_cyclic_l1a_cnt" fw_default="0x002710"/>
        <node id="CYCLIC_RUNNING" address="0x1" mask="0x00000002" permission="r"
              description="This register indicates if the cyclic generator is running or not"
              fw_signal="gen_cyclic_l1a_running"/>
        <node id="CYCLIC_START" address="0x6" permission="w"
              description="Writing to this register will trigger a start of the cyclic generator"
              fw_write_pulse_signal="gen_cyclic_l1a_start"/>
      </node>
      
    </node>
    <!--end TTC module -->

    <!--Trigger module -->
    <node id="TRIGGER"  address="0x00800000"
          description="Trigger module handles everything related to sbit cluster data
                       (link synchronization, monitoring, local triggering, matching to L1A and reporting data to DAQ)"
          fw_is_module="true"
          fw_module_file="../common/hdl/trigger/trigger.vhd"
          fw_user_clock_signal="ttc_clk_i.clk_40"
          fw_bus_clock_signal="ipb_clk_i"
          fw_bus_reset_signal="ipb_reset_i"
          fw_master_bus_signal="ipb_mosi_i"
          fw_slave_bus_signal="ipb_miso_o"
          fw_reg_addr_msb="12"
          fw_reg_addr_lsb="0">

      <node id="CTRL" address="0x0"
            description="Trigger control">
        <node id="MODULE_RESET" address="0x0" permission="w"
              description="Trigger module reset"
              fw_write_pulse_signal="reset_local"/>
        <node id="CNT_RESET" address="0x1" permission="w"
              description="Trigger counter reset"
              fw_write_pulse_signal="reset_cnt"
              sw_ctrl_configure_set="0x1" sw_ctrl_start_set="0x1"/>
        <node id="OH_KILL_MASK" address="0x2" mask="0x00ffffff" permission="rw"
              description="OH trigger kill mask (kills all sbits from the corresponding OHs)"
              fw_signal="oh_mask"
              fw_default="0x000000"/>
        <node id="SECTOR_ID" address="0x2" mask="0x0f000000" permission="rw"
              description="Sector ID that gets embedded in the TX links to EMTF"
              fw_signal="sector_id"
              fw_default="0x0"/>
      </node>

      <node id="STATUS" address="0x10"
            description="Trigger status">
        <node id="OR_TRIGGER_RATE" address="0x0" permission="r"
              description="OR-Trigger rate (Hz) -- this trigger fires whenever there's at least one valid sbit cluster on any link"
              fw_signal="or_trigger_rate"
              sw_monitor_warn_min_threshold="1000000"/>
        <node id="OR_TRIGGER_CNT" address="0x1" permission="r"
              description="OR-Trigger count -- this trigger fires whenever there's at least one valid sbit cluster on any link"
              fw_signal="or_trigger_cnt"/>
      </node>

      <node id="SBIT_MONITOR" address="0x80"
            description="sbit monitor module which shows the first valid sbit clusters after a reset on the selected link">
        <node id="RESET" address="0x0" permission="w"
              description="Reset the sbit monitor module and re-arm for triggering"
              fw_write_pulse_signal="sbitmon_reset"/>
        <node id="OH_SELECT" address="0x1" mask="0x0000000f" permission="rw"
              description="Selects the OH to monitor and trigger on"
              fw_signal="sbitmon_link_select"
              fw_default="0x0"/>
        <node id="CLUSTER${CLUSTER_IDX}" address="0x2" mask="0x0000ffff" permission="r"
              description="Last cluster ${CLUSTER_IDX}"
              fw_signal="'0' &amp; sbitmon_sbits(${CLUSTER_IDX}).size &amp; '0' &amp; sbitmon_sbits(${CLUSTER_IDX}).address"
              generate="true" generate_size="8" generate_address_step="0x1" generate_idx_var="CLUSTER_IDX"/>
        <node id="L1A_DELAY" address="0xa" mask="0xffffffff" permission="r"
              description="Number of BX between this sbit and the subsequent L1A"
              fw_signal="sbitmon_l1a_delay"/>
      </node>

      <node id="OH${OH_IDX}" address="0x100"
            description="Trigger link for OH ${OH_IDX}"
            generate="true" generate_size="12" generate_address_step="0x100" generate_idx_var="OH_IDX">
        <node id="TRIGGER_RATE" address="0x0" permission="r"
              description="Trigger rate (Hz) -- this trigger fires whenever there's at least one valid sbit cluster"
              fw_signal="trigger_rate(${OH_IDX})"
              sw_monitor_warn_min_threshold="1000000"/>
        <node id="TRIGGER_CNT" address="0x1" permission="r"
              description="Trigger count -- this trigger fires whenever there's at least one valid sbit cluster"
              fw_signal="trigger_cnt(${OH_IDX})"
              sw_monitor_warn_min_threshold="1000000"/>
        <node id="CLUSTER_SIZE_${CS_IDX}_RATE" address="0x10" permission="r"
              description="Rate of cluster size ${CS_IDX} (size 0 means no sbit clusters)"
              fw_signal="cluster_cnt_rate(${OH_IDX} * 9 + ${CS_IDX})"
              generate="true" generate_size="9" generate_address_step="0x1" generate_idx_var="CS_IDX"/>
        <node id="CLUSTER_SIZE_${CS_IDX}_CNT" address="0x20" permission="r"
              description="Count of cluster size ${CS_IDX} (size 0 means no sbit clusters)"
              fw_signal="cluster_cnt(${OH_IDX} * 9 + ${CS_IDX})"
              generate="true" generate_size="9" generate_address_step="0x1" generate_idx_var="CS_IDX"/>
        <node id="LINK0_SBIT_OVERFLOW_CNT" address="0xa0" mask="0x0000ffff" permission="r"
              description="Count of overflow markers received from OH on lin 0"
              fw_signal="sbit_overflow_cnt(${OH_IDX})(15 downto 0)"
              sw_monitor_error_min_threshold="100"/>
        <node id="LINK1_SBIT_OVERFLOW_CNT" address="0xa0" mask="0xffff0000" permission="r"
              description="Count of overflow markers received from OH on link 1"
              fw_signal="sbit_overflow_cnt(${OH_IDX})(31 downto 16)"
              sw_monitor_error_min_threshold="100"/>
        <node id="LINK0_MISSED_COMMA_CNT" address="0xa1" mask="0x0000ffff" permission="r"
              description="Count of missed comma character at the expected time for link 0 (this indicates an out-of-sync condition)"
              fw_signal="missed_comma_cnt(${OH_IDX})(15 downto 0)"
              sw_monitor_error_min_threshold="1"/>
        <node id="LINK1_MISSED_COMMA_CNT" address="0xa1" mask="0xffff0000" permission="r"
              description="Count of missed comma character at the expected time for link 1 (this indicates an out-of-sync condition)"
              fw_signal="missed_comma_cnt(${OH_IDX})(31 downto 16)"
              sw_monitor_error_min_threshold="1"/>
        <node id="LINK0_OVERFLOW_CNT" address="0xa3" mask="0x0000ffff" permission="r"
              description="Count of overflow occurances in the sync FIFO for link 0"
              fw_signal="link_overflow_cnt(${OH_IDX})(15 downto 0)"
              sw_monitor_error_min_threshold="1"/>
        <node id="LINK1_OVERFLOW_CNT" address="0xa3" mask="0xffff0000" permission="r"
              description="Count of overflow occurances in the sync FIFO for link 1"
              fw_signal="link_overflow_cnt(${OH_IDX})(31 downto 16)"
              sw_monitor_error_min_threshold="1"/>
        <node id="LINK0_UNDERFLOW_CNT" address="0xa4" mask="0x0000ffff" permission="r"
              description="Count of underflow occurances in the sync FIFO for link 0"
              fw_signal="link_underflow_cnt(${OH_IDX})(15 downto 0)"
              sw_monitor_error_min_threshold="1"/>
        <node id="LINK1_UNDERFLOW_CNT" address="0xa4" mask="0xffff0000" permission="r"
              description="Count of underflow occurances in the sync FIFO for link 1"
              fw_signal="link_underflow_cnt(${OH_IDX})(31 downto 16)"
              sw_monitor_error_min_threshold="1"/>
        <node id="LINK0_SYNC_WORD_CNT" address="0xa5" mask="0x0000ffff" permission="r"
              description="Count of sync words seen on link 0"
              fw_signal="sync_word_cnt(${OH_IDX})(15 downto 0)"/>
        <node id="LINK1_SYNC_WORD_CNT" address="0xa5" mask="0xffff0000" permission="r"
              description="Count of sync words seen on link 1"
              fw_signal="sync_word_cnt(${OH_IDX})(31 downto 16)"/>
      </node>

    </node>
    <!--end trigger module -->

    <!--GEM System module -->
    <node id="GEM_SYSTEM"  address="0x00900000"
          description="This module is controlling GEM AMC System wide settings"
          fw_is_module="true"
          fw_module_file="../common/hdl/misc/gem_system_regs.vhd"
          fw_user_clock_signal="ttc_clks_i.clk_40"
          fw_bus_clock_signal="ipb_clk_i"
          fw_bus_reset_signal="ipb_reset_i"
          fw_master_bus_signal="ipb_mosi_i"
          fw_slave_bus_signal="ipb_miso_o"
          fw_reg_addr_msb="16"
          fw_reg_addr_lsb="0">

      <node id="CTRL" address="0x100">
        <node id="GLOBAL_RESET" address="0x0" permission="w"
              description="Global reset of the GEM logic (resets all modules)"
              fw_write_pulse_signal="global_reset_trig"
              sw_ctrl_configure_set="0x1"/>
        <node id="LINK_RESET" address="0x1" permission="w"
              description="Reset the links to and from OHs and redo VFAT3 sync procedure"
              fw_write_pulse_signal="manual_link_reset_o"
              sw_ctrl_configure_set="0x1"/>
        <node id="IPBUS_RESET" address="0x2" permission="w"
              description="Reset of all registers to their default value"
              fw_write_pulse_signal="ipbus_reset_trig"
              sw_ctrl_configure_set="0x1"/>
      </node>

      <node id="BOARD_ID" address="0x2" mask="0x0000ffff" permission="rw"
            description="Board ID that gets embedded in the AMC13 header"
            fw_signal="board_id" fw_default="0xbeef"/>
      <node id="BOARD_TYPE" address="0x2" mask="0x000f0000" permission="r"
            description="Board type: 0 means GLIB, 1 means CTP7"
            fw_signal="board_type"/>

      <node id="RELEASE" address="0x3">
        <node id="MAJOR" address="0x0" mask="0x00ff0000" permission="r"
              description="Firmware release major version"
              fw_signal="std_logic_vector(to_unsigned(version_major, 8))"/>
        <node id="MINOR" address="0x0" mask="0x0000ff00" permission="r"
              description="Firmware release minor version"
              fw_signal="std_logic_vector(to_unsigned(version_minor, 8))"/>
        <node id="BUILD" address="0x0" mask="0x000000ff" permission="r"
              description="Firmware release build version"
              fw_signal="std_logic_vector(to_unsigned(version_build, 8))"/>
        <node id="GEM_STATION" address="0x0" mask="0x03000000" permission="r"
              description="GEM station that this firmware was compiled for (0 means ME0, 1 means GE1/1, 2 means GE2/1)"
              fw_signal="std_logic_vector(to_unsigned(gem_station, 2))"/>
        <node id="DATE" address="0x1" permission="r"
              description="Firmware release date (read as hex)"
              fw_signal="firmware_date"/>
      </node>

      <node id="CONFIG" address="0x5">
        <node id="NUM_OF_OH" address="0x0" mask="0x0000001f" permission="r"
              description="Number of supported optohybrids"
              fw_signal="num_of_oh"/>
      </node>

      <node id="VFAT3" address="0x10">
        <node id="SC_ONLY_MODE" address="0x1" mask="0x00000002" permission="rw"
              description="When this is set to 0 then comm port of VFAT3s will be set to normal mode, otherwise they will be set to slow-control-only mode. This setting is applied to all VFATs during link reset and whenever this value is changed."
              fw_signal="vfat3_sc_only_mode" fw_default="0b0"/>
        <node id="USE_OH_V3B_MAPPING" address="0x1" mask="0x00000004" permission="rw"
              description="If set high, then will use the v3b elink assignments for the OH FPGA communication, otherwise v3a"
              fw_signal="use_v3b_elink_mapping" fw_default="0b1"/>
        <node id="USE_VFAT_ADRESSING" address="0x1" mask="0x00000008" permission="rw"
              description="If set high, then HDLC address will be set to the same number as the slot number when sending slow control packets to VFATs -- note this requires that the HDLC address is set accordingly on the GEB. If this is 0, then an HDLC address of 0 is always used for all slots (default VFAT address when HDLC address pins are left unconnected)"
              fw_signal="use_vfat_addressing" fw_default="0b0"/>
      </node>

      <node id="TESTS" address="0x200">
        <node id="GBT_LOOPBACK_EN" address="0x0" mask="0x00000001" permission="rw"
              description="GBT Loopback test enable -- if this is true then all GBT links are redirected to the loopback test
                           module and the test module is enabled (communication with optohybrid is not possible during the test)"
              fw_signal="loopback_gbt_test_en" fw_default="0b0"
              sw_ctrl_configure_set="0x0" sw_ctrl_start_set="0x0"/>
      </node>

      <node id="GEM_LOADER" address="0x400">
        <node id="LOAD_REQUEST_CNT" address="0x0" mask="0x0000ffff" permission="r"
              description="Number of OH programming requests (note, the counter is 16bit rolling)"
              fw_signal="gemloader_stats_i.load_request_cnt"/>
        <node id="LOAD_SUCCESS_CNT" address="0x0" mask="0xffff0000" permission="r"
              description="Number of successful OH programming attempts (note, the counter is 16bit rolling)"
              fw_signal="gemloader_stats_i.success_cnt"/>
        <node id="LOAD_FAIL_CNT" address="0x1" mask="0x0000ffff" permission="r"
              description="Number of failed OH programming attempts (note, the counter is 16bit rolling)"
              fw_signal="gemloader_stats_i.fail_cnt"/>
        <node id="STREAM_GAP_CNT" address="0x1" mask="0xffff0000" permission="r"
              description="Number of times that a gap has been detected in the bitfile stream before reaching the end (note, the counter is 16bit rolling)"
              fw_signal="gemloader_stats_i.gap_detect_cnt"/>
        <node id="LOADER_OVF_UNF_CNT" address="0x2" mask="0x0000ffff" permission="r"
              description="Number of times that the gemloader IP has reported a FIFO overflow or underflow (note, the counter is 16bit rolling)"
              fw_signal="gemloader_stats_i.loader_ovf_unf_cnt"/>
      </node>

    </node>

    <!--GEM Tests module -->
    <node id="GEM_TESTS"  address="0x00A00000"
          description="This module is controlling various hardware tests e.g. fiber loopback"
          fw_is_module="true"
          fw_module_file="../common/hdl/tests/gem_tests.vhd"
          fw_user_clock_signal="ttc_clk_i.clk_40"
          fw_bus_clock_signal="ipb_clk_i"
          fw_bus_reset_signal="ipb_reset_i"
          fw_master_bus_signal="ipb_mosi_i"
          fw_slave_bus_signal="ipb_miso_o"
          fw_reg_addr_msb="16"
          fw_reg_addr_lsb="0">

      <node id="CTRL" address="0x0">
        <node id="RESET" address="0x0" permission="w"
              description="reset all test modules"
              fw_write_pulse_signal="reset_local"/>
      </node>

      <node id="OH_LOOPBACK" address="0x1000"
              description="This module controls the OH PRBS loopback tester (this tester can be connected to one OH at a time by using the OH_SELECT register). This module sends a PRBS7 8b sequence to all elinks of the chosen OH, and checks each elink of that OH with the same sequence checker">
        <node id="CTRL" address="0x0">
          <node id="RESET" address="0x0" permission="w"
                description="reset the PRBS loopback module"
                fw_write_pulse_signal="gbt_loop_reset"/>
          <node id="OH_SELECT" address="0x1" mask="0x0000000f" permission="rw"
		        description="This register sets the index of the OH that the loopback tester is going to be testing"
		        fw_signal="gbt_loop_oh_select" fw_default="0x0"/>
          <node id="INJECT_ERR" address="0x2" permission="w"
		        description="Writing to this register will result in one error being injected to the PRBS TX data going to the OH"
            fw_write_pulse_signal="gbt_loop_err_inject"/>
        </node>
        <node id="GBT_${GBT_IN_OH_IDX}"  address="0x10"
              description="Link specific registers for GBT ${GBT_IN_OH_IDX}"
              generate="true" generate_size="3" generate_address_step="0x100" generate_idx_var="GBT_IN_OH_IDX">

          <node id="ELINK_${ELINK_IDX}"  address="0x0"
                description="E-link specific registers for e-link ${ELINK_IDX}"
                generate="true" generate_size="14" generate_address_step="0x2" generate_idx_var="ELINK_IDX">

            <node id="PRBS_LOCKED" mask="0x80000000" permission="r" address="0x0"
                  description="Indicates whether or not the PRBS7 checker is locked on this elink"
                  fw_signal="gbt_loop_locked_arr(${GBT_IN_OH_IDX} * 14 + ${ELINK_IDX})"/>
            <node id="MEGA_WORD_CNT" permission="r" address="0x1"
                  description="Number of generated data words in units of one million received by this RX elink after PRBS checker has locked"
                  fw_signal="gbt_loop_mega_word_cnt_arr(${GBT_IN_OH_IDX} * 14 + ${ELINK_IDX})"/>
            <node id="ERROR_CNT" mask="0x7fffffff" permission="r" address="0x0"
                  description="Number of PRBS7 errors found in the received data for this elink"
                  fw_signal="gbt_loop_error_cnt_arr(${GBT_IN_OH_IDX} * 14 + ${ELINK_IDX})(30 downto 0)"/>
          </node>
        </node>
      </node>

      <node id="VFAT_DAQ_MONITOR" address="0x2000"
              description="This module listens to the DAQ data of 24 VFATs from a selected OH 
                           and counts the number of good events received and the number of times a selected channel (or any channel) has fired.
                           This is useful for various scan routines.">
        <node id="CTRL" address="0x0">
          <node id="RESET" address="0x0" permission="w"
                description="reset all the VFAT DAQMON modules"
                fw_write_pulse_signal="vfat_daqmon_reset"/>
	      <node id="ENABLE" address="0x1" mask="0x00000001" permission="rw"
		        description="This register lets you enable and disable all VFAT DAQMON modules. When disabled all the counters are frozen."
		        fw_signal="vfat_daqmon_enable" fw_default="0b0"/>
	      <node id="OH_SELECT" address="0x1" mask="0x000000f0" permission="rw"
		        description="Selects the desired OH"
		        fw_signal="vfat_daqmon_oh_select" fw_default="0x0"/>
	      <node id="VFAT_CHANNEL_SELECT" address="0x1" mask="0x00007f00" permission="rw"
		        description="Selects the VFAT channel number to listen to"
		        fw_signal="vfat_daqmon_chan_select" fw_default="0x0"/>
	      <node id="VFAT_CHANNEL_GLOBAL_OR" address="0x1" mask="0x00008000" permission="rw"
		        description="If this is set to 1 then the VFAT DAQMONs will OR all the VFAT channels together and ignore the VFAT_CHANNEL_SELECT"
		        fw_signal="vfat_daqmon_chan_global_or" fw_default="0x0"/>
        </node>
        <node id="VFAT${VFAT_IDX}"  address="0x10"
              description="VFAT DAQMON counters for VFAT${VFAT_IDX}"
              generate="true" generate_size="24" generate_address_step="0x10" generate_idx_var="VFAT_IDX">

          <node id="GOOD_EVENTS_COUNT" mask="0x0000ffff" permission="r" address="0x0"
                description="Number of good events received from this VFAT (good event means that CRC check has passed ok)"
                fw_signal="vfat_daqmon_good_evt_cnt_arr(${VFAT_IDX})"/>
          <node id="CHANNEL_FIRE_COUNT" mask="0xffff0000" permission="r" address="0x0"
                description="Number of times the selected channel has fired"
                fw_signal="vfat_daqmon_chan_fire_cnt_arr(${VFAT_IDX})"/>

        </node>
      </node>

    </node>

    <!--DAQ module -->
    <node id="DAQ"  address="0x00700000"
          description="DAQ module buffers track data, builds events, analyses the data for consistency
                       and ships off the events with all the needed headers and trailers to AMC13 over DAQLink"
          fw_is_module="true"
          fw_module_file="../common/hdl/daq/daq.vhd"
          fw_user_clock_signal="ipb_clk_i"
          fw_bus_clock_signal="ipb_clk_i"
          fw_bus_reset_signal="ipb_reset_i"
          fw_master_bus_signal="ipb_mosi_i"
          fw_slave_bus_signal="ipb_miso_o"
          fw_reg_addr_msb="8"
          fw_reg_addr_lsb="0">

      <node id="CONTROL"  address="0x0"
            description="DAQ Control">
        <node id="DAQ_ENABLE"         address="0x0" mask="0x00000001" permission="rw"
              description="If this is set to 0, there will be no data sent to AMC13 and TTS state will always be READY (0x8)"
              fw_signal="daq_enable" fw_default="0b0"/>
        <node id="DAQ_LINK_RESET"     address="0x0" mask="0x00000004" permission="rw"
              description="Directly connected to DAQLink module reset port. BU is
                           advising against ever using it except for powerup, but it
                           may clear some error conditions (like daqlink_almost_ful
                           stuck at 1). AMC13 reset is probably required after this."
              fw_signal="reset_daqlink_ipb" fw_default="0b0"/>
        <node id="RESET"              address="0x0" mask="0x00000008" permission="rw"
              description="Clears all FIFOs, state flags and counters. It also stops and
                           resets all state machines (no events will be built, recorded
                           or sent during reset)
                           When set to 1, it will be held in reset state until 0 is
                           explicitly written (this can be changed in the future if
                           necessary)"
              fw_signal="reset_local" fw_default="0b0"/>
        <node id="ZERO_SUPPRESSION_EN"              address="0x0" mask="0x00000002" permission="rw"
              description="Enable/disable VFAT2 zero suppression"
              fw_signal="zero_suppression_en" fw_default="0b0"/>
        <node id="TTS_OVERRIDE"       address="0x0" mask="0x000000f0" permission="rw"
              description="When not 0, it will override the AMC TTS state with the
                           provided value (e.g. writing 0x8 will force AMC to always be
                           in TTS READY state)"
              fw_signal="tts_override" fw_default="0x0"/>
        <node id="INPUT_ENABLE_MASK"  address="0x0" mask="0xffffff00" permission="rw"
              description="This is a bitmask telling AMC to enable certain inputs (least
                           significant bit is input 0). Only first is enabled by default"
              fw_signal="input_mask" fw_default="0x1"/>
        <node id="DAV_TIMEOUT"        address="0x1"  mask="0x00ffffff" permission="rw"
              description="This setting controls how long DAQ will wait for individual
                           inputs to report data before calling it timed-out  (if timeout
                           occurs a header and trailer for that chamber will still be
                           inserted and timeout flag will be set there, though no VFAT
                           payload will be present). Units = clock cycles @ 25MHz
                           (current DAQLink clk frequency)"
              fw_signal="dav_timeout" fw_default="0x00500"/>
        <node id="DBG_FANOUT_ENABLE"        address="0x1"  mask="0x01000000" permission="rw"
              description="This register enables and disables the fanout feature.
                           This feature is used for testing only. When enabled it will
                           take the data input from one OH and fan it out to all DAQ module
                           inputs. The input to be used is controlled by DBG_FANOUT_INPUT reg."
              fw_signal="dbg_fanout_enable" fw_default="0b0"/>
        <node id="DBG_FANOUT_INPUT"        address="0x1"  mask="0xf0000000" permission="rw"
              description="Selects the input to be faned out when the fanout feature is enabled (see DBG_FANOUT_ENABLE)."
              fw_signal="dbg_fanout_input" fw_default="0x0"/>
        <node id="DBG_IGNORE_DAQLINK"        address="0x1"  mask="0x02000000" permission="rw"
              description="This register when set to 1 will cause the DAQ module to ignore the DAQLink ready and DAQLink backpressure signals.
                           It can be used for fake datarate testing without involving AMC13."
              fw_signal="dbg_daqlink_ignore" fw_default="0b0"/>
        <node id="CALIBRATION_MODE_EN"       address="0x2"  mask="0x00000080" permission="rw"
              description="When set, this enables calibration mode data format, which strips the VFAT payload of most of the data, just leaving 8 bits per VFAT, where [4:0] is the VFAT position, [6:5] is EC, and bit 7 is the chanel information for the channel selected in CALIBRATION_MODE_CHAN (see below)"
              fw_signal="format_calib_mode" fw_default="0b0"/>
        <node id="CALIBRATION_MODE_CHAN"       address="0x2"  mask="0x0000007f" permission="rw"
              description="Channel number for which data will be included in the calibration mode data format (see CALIBRATION_MODE_EN)"
              fw_signal="format_calib_chan" fw_default="0b0000000"/>
      </node>

      <node id="EXT_CONTROL"  address="0x40"
            description="DAQ global extended configuration registers">
        <node id="RUN_TYPE"       address="0x0"  mask="0x0f000000" permission="rw"
              description="User settable run type that gets embedded into the AMC header"
              fw_signal="run_type" fw_default="0x0"/>
        <node id="RUN_PARAMS"     address="0x0"  mask="0x00ffffff" permission="rw"
              description="User settable run params that gets embedded into the AMC header"
              fw_signal="run_params" fw_default="0x000000"/>
      </node>

      <node id="STATUS"  address="0x50"
            description="DAQ global status registers">
        <node id="DAQ_LINK_RDY"    address="0x0"  mask="0x00000001" permission="r"
              description="When this is 1, it means that AMC is in good communication
                           with AMC13. It must be 1 for AMC to be able to send data."
              fw_signal="daq_ready"/>
        <node id="DAQ_CLK_LOCKED"  address="0x0"  mask="0x00000002" permission="r"
              description="This flag is 1 if DAQ clock is locked at this moment"
              fw_signal="daq_clk_locked_i"/>
        <node id="TTC_RDY"         address="0x0"  mask="0x00000004" permission="r"
              description="This flag is 1 if TTC clock MMCM is locked"
              fw_signal="ttc_status_i.clk_status.mmcm_locked"/>
        <node id="DAQ_LINK_AFULL"       address="0x0"  mask="0x00000008" permission="r"
              description="This bit comes directly from DAQLink module, indicating
                           that its internal buffers are almost full. No events will be sent
                           when this bit is 1 (though events can still be built and
                           stored in the Input and Event FIFOs)"
              fw_signal="daq_almost_full"
              sw_monitor_error_min_threshold="1"/>
        <node id="DAQ_OUTPUT_FIFO_HAD_OVERFLOW"       address="0x0"  mask="0x00000010" permission="r"
              description="This bit is set if DAQ output FIFO has ever been full (critical -- data loss)"
              fw_signal="err_daqfifo_full"
              sw_monitor_error_min_threshold="1"/>
        <node id="TTC_BC0_LOCKED"       address="0x0"  mask="0x00000020" permission="r"
              description="This bit is set if BC0 is currently locked (last BC0 arrived at the expected time)"
              fw_signal="ttc_status_i.bc0_status.locked"/>
        <node id="L1A_FIFO_HAD_OVERFLOW"       address="0x0"  mask="0x00800000" permission="r"
              description="This bit is latched whenever L1A FIFO overflow is asserted.
                           This means that one or more L1As were lost, so we are
                           out-of-sync: resync or reset is needed"
              fw_signal="err_l1afifo_full"
              sw_monitor_error_min_threshold="1"/>
        <node id="L1A_FIFO_IS_UNDERFLOW"       address="0x0"  mask="0x01000000" permission="r"
              description="L1A FIFO is in underflow at this moment (this bit is not latched)"
              fw_signal="l1afifo_underflow"
              sw_monitor_error_min_threshold="1"/>
        <node id="L1A_FIFO_IS_FULL"       address="0x0"  mask="0x02000000" permission="r"
              description="L1A FIFO is full at this moment (this bit is not latched)"
              fw_signal="l1afifo_full"
              sw_monitor_error_min_threshold="1"/>
        <node id="L1A_FIFO_IS_NEAR_FULL"       address="0x0"  mask="0x04000000" permission="r"
              description="This bit gets asserted when L1A FIFO gets 75% full and deasserted when it gets down to 50%"
              fw_signal="l1afifo_near_full"/>
        <node id="L1A_FIFO_IS_EMPTY"       address="0x0"  mask="0x08000000" permission="r"
              description="L1A FIFO is empty at this moment (this bit is not latched)"
              fw_signal="l1afifo_empty"/>
        <node id="TTS_STATE"       address="0x0"  mask="0xf0000000" permission="r"
              description="Current TTS state (READY, BUSY, ERROR, WARN, OUT-OF-SYNC)"
              fw_signal="tts_state"/>
      </node>

      <node id="EXT_STATUS"  address="0x80"
            description="DAQ global extended status registers">
        <node id="NOTINTABLE_ERR"  address="0x0"  mask="0x0000ffff" permission="r"
              description="This counter is counting DAQLink GTX/GTH not-in-table errors"
              fw_signal="daq_notintable_err_cnt"/>
        <node id="DISPER_ERR"      address="0x1"  mask="0x0000ffff" permission="r"
              description="This counter is counting DAQLink GTX/GTH dispersion errors"
              fw_signal="daq_disper_err_cnt"/>
        <node id="L1AID"           address="0x2"  mask="0x00ffffff" permission="r"
              description="Current L1A ID (similar to event number, but this may be a bit ahead of
                           that if we're still waiting for data for unprocessed L1As)"
              fw_signal="ttc_daq_cntrs_i.l1id"/>
        <node id="EVT_SENT"        address="0x3"  permission="r"
              description="Number of events shipped out to DAQLink"
              fw_signal="std_logic_vector(cnt_sent_events)"/>
        <node id="MAX_DAV_TIMER"   address="0x5"  mask="0x00ffffff" permission="r"
              description="This indicates the maximum amount of time that DAQ had
                           to wait for all inputs to report data (can be used to optimize
                           DAV timeout setting). Units = clock cycles @ DAQ clock frequency (currently using 40.08MHz TTC clock)
                           (current DAQLink clk frequency)"
              fw_signal="std_logic_vector(max_dav_timer)"/>
        <node id="LAST_DAV_TIMER"  address="0x6"  mask="0x00ffffff" permission="r"
              description="This indicates how DAQ had to wait for all inputs to report
                           data for the last event (mostly for debugging). Units = clock
                           cycles @ DAQ clock frequency (currently using 40.08MHz TTC clock)"
              fw_signal="std_logic_vector(last_dav_timer)"/>
        <node id="L1A_FIFO_DATA_CNT"  address="0x7"  mask="0x00001fff" permission="r"
              description="Current number of words in the L1A FIFO (current depth is 8192)"
              fw_signal="l1afifo_data_cnt"/>
        <node id="DAQ_FIFO_DATA_CNT"  address="0x7"  mask="0x1fff0000" permission="r"
              description="Current number of words in the DAQ output FIFO (current depth is 8192)"
              fw_signal="daqfifo_data_cnt"/>
        <node id="L1A_FIFO_NEAR_FULL_CNT"  address="0x8"  mask="0x0000ffff" permission="r"
              description="Number of clocks L1A FIFO was near-full (asserted at 75%, deasserted at 50%)"
              fw_signal="l1afifo_near_full_cnt"
              sw_monitor_warn_min_threshold="100"/>
        <node id="DAQ_FIFO_NEAR_FULL_CNT"  address="0x8"  mask="0xffff0000" permission="r"
              description="Number of clocks DAQ output FIFO was near-full (asserted at 75%, deasserted at 50%)"
              fw_signal="daqfifo_near_full_cnt"
              sw_monitor_warn_min_threshold="100"/>
        <node id="DAQ_ALMOST_FULL_CNT"  address="0x9"  mask="0x0000ffff" permission="r"
              description="Number of clocks DAQLink has asserted almost-full flag"
              fw_signal="daqlink_afull_cnt"/>
        <node id="TTS_WARN_CNT"  address="0x9"  mask="0xffff0000" permission="r"
              description="Number of clocks we reported TTS WARNING state"
              fw_signal="tts_warning_cnt"
              sw_monitor_warn_min_threshold="100"/>
        <node id="DAQ_WORD_RATE"  address="0xa"  permission="r"
              description="Rate of 64bit words being sent out to the DAQLink in Hz (multiply by 64 to get bitrate)"
              fw_signal="daq_word_rate"
              sw_monitor_warn_min_threshold="40000"/> <!-- currently running DAQ at 50MHz, which is 3.2Gbs, so warning at 2.5Gbs (could increase to 80MHz to get 5Gbs) -->
      </node>

      <node id="OH${OH_IDX}"  address="0x100"
            description="Link specific registers for OH${OH_IDX}"
            generate="true" generate_size="12" generate_address_step="0x10" generate_idx_var="OH_IDX">

        <node id="CONTROL"  address="0x0">
          <node id="EOE_TIMEOUT" address="0x3"  mask="0x00ffffff" permission="rw"
                description="Units = clock cycles @ 160MHz.
                             If no new data was received in this amount of time, AMC
                             will close the current event and report it to DAQ. This is one
                             of the two ways to close an event, the other is to get new
                             data with different BX number"
                fw_signal="input_control_arr(${OH_IDX}).eb_timeout_delay" fw_default="0x000100"/>
        </node>

        <node id="STATUS"  address="0x0">
          <node id="VFAT_MIXED_EC"    mask="0x00000002" permission="r" address="0x0"
                description="There was at least one event with mixed VFAT Event IDs"
                fw_signal="input_status_arr(${OH_IDX}).err_mixed_vfat_ec"/>
          <node id="VFAT_MIXED_BC"  mask="0x00000004" permission="r" address="0x0"
                description="There was at least one event with mixed VFAT BX IDs"
                fw_signal="input_status_arr(${OH_IDX}).err_mixed_vfat_bc"/>
          <node id="OH_MIXED_BC"         mask="0x00000008" permission="r" address="0x0"
                description="There was at least one event with mixed OH BX IDs (OH BX
                             ID is reported for every VFAT block, but not sent to
                             AMC13)."
                fw_signal="input_status_arr(${OH_IDX}).err_mixed_oh_bc"/>

          <node id="VFAT_TOO_MANY"      mask="0x00000010" permission="r" address="0x0"
                description="Corruption: more than 24 VFATs in event"
                fw_signal="input_status_arr(${OH_IDX}).err_event_bigger_than_24"/>
          <node id="VFAT_SMALL_BLOCK"   mask="0x00000020" permission="r" address="0x0"
                description="Corruption: VFAT block smaller than 192bits"
                fw_signal="input_status_arr(${OH_IDX}).err_vfat_block_too_small"/>
          <node id="VFAT_LARGE_BLOCK"   mask="0x00000040" permission="r" address="0x0"
                description="Corruption: VFAT block bigger than 192bits"
                fw_signal="input_status_arr(${OH_IDX}).err_vfat_block_too_big"/>
          <node id="VFAT_NO_MARKER"     mask="0x00000080" permission="r" address="0x0"
                description="Corruption: VFAT marker not detected.
                             There was at least one VFAT block not conforming to the
                             pattern of Axxx Cxxx Exxx... (see VFAT data format)
                             Note that this data will still be included in the current event
                             and sent to AMC13, but it will not be considered in
                             end-of-event detection"
                fw_signal="input_status_arr(${OH_IDX}).err_corrupted_vfat_data"/>
          <node id="INPUT_FIFO_HAD_OFLOW"   mask="0x00000100" permission="r" address="0x0"
                description="Critical: Input FIFO overflow occurred.
                             This bit is latched if Input FIFO was ever full when receiving
                             new data - this means data was lost.
                             TTS ERROR is asserted when this bit is 1"
                fw_signal="input_status_arr(${OH_IDX}).err_infifo_full"/>
          <node id="INPUT_FIFO_HAD_UFLOW"   mask="0x00000200" permission="r" address="0x0"
                description="Critical: Input FIFO underflow occurred.
                             This bit is latched if Input FIFO underflow was ever
                             detected. This means that Event FIFO indicated that there
                             should be more data than was stored in Input FIFO. This
                             might happen due to overflow or some other malfunction.
                             TTS ERROR is asserted when this bit is 1"
                fw_signal="input_status_arr(${OH_IDX}).err_infifo_underflow"/>
          <node id="EVENT_FIFO_HAD_OFLOW"   mask="0x00000400" permission="r" address="0x0"
                description="Critical: Event FIFO overflow occurred.
                             This bit is latched if Event FIFO was ever full when trying to
                             build a new event. This means data was lost.
                             It's not likely that this will ever be asserted because Input
                             FIFO should overflow first.
                             TTS ERROR is asserted when this bit is 1"
                fw_signal="input_status_arr(${OH_IDX}).err_evtfifo_full"/>
          <node id="EVT_SIZE_ERR"           mask="0x00000800" permission="r" address="0x0"
                description="Critical: Event size overflow occurred.
                             This bit is latched if there was an event containing more
                             than 4096 VFAT blocks. Input FIFO and Event FIFO will be
                             out-of-sync. This might happen if end-of-event is not
                             detected properly or for whatever reason AMC is receiving
                             a stream of VFAT blocks indicating that they belong to the
                             same event (EC/BC is the same)
                             TTS ERROR is asserted when this bit is 1"
                fw_signal="input_status_arr(${OH_IDX}).err_event_too_big"/>
          <node id="VFAT_INPUT_HAD_OVF"           mask="0x00010000" permission="r" address="0x0"
                description="Individual VFAT input buffer had overflow. This indicates a logic problem in the firmware and therefore is a critical error"
                fw_signal="input_status_arr(${OH_IDX}).vfat_fifo_ovf"/>
          <node id="VFAT_INPUT_HAD_UNF"           mask="0x00020000" permission="r" address="0x0"
                description="Individual VFAT input buffer had underflow. This indicates a logic problem in the firmware and therefore is a critical error"
                fw_signal="input_status_arr(${OH_IDX}).vfat_fifo_unf"/>
          <node id="TTS_STATE"           mask="0x0000f000" permission="r" address="0x0"
                description="Input TTS state (gets integrated into global TTS state later)"
                fw_signal="input_status_arr(${OH_IDX}).tts_state"/>
          <node id="INPUT_FIFO_IS_UFLOW"    mask="0x01000000" permission="r" address="0x0"
                description="Current status: Input FIFO is in underflow"
                fw_signal="input_status_arr(${OH_IDX}).infifo_underflow"/>
          <node id="INPUT_FIFO_IS_FULL"     mask="0x02000000" permission="r" address="0x0"
                description="Current status: Input FIFO is full"
                fw_signal="input_status_arr(${OH_IDX}).infifo_full"/>
          <node id="INPUT_FIFO_IS_AFULL"    mask="0x04000000" permission="r" address="0x0"
                description="Current status: Input FIFO is near-full (asserted at 75% and deasserted at 50%)"
                fw_signal="input_status_arr(${OH_IDX}).infifo_near_full"/>
          <node id="INPUT_FIFO_IS_EMPTY"    mask="0x08000000" permission="r" address="0x0"
                description="Current status: Input FIFO is empty"
                fw_signal="input_status_arr(${OH_IDX}).infifo_empty"/>
          <node id="EVENT_FIFO_IS_UFLOW"    mask="0x10000000" permission="r" address="0x0"
                description="Current status: Event FIFO is in underflow"
                fw_signal="input_status_arr(${OH_IDX}).evtfifo_underflow"/>
          <node id="EVENT_FIFO_IS_FULL"     mask="0x20000000" permission="r" address="0x0"
                description="Current status: Event FIFO is full"
                fw_signal="input_status_arr(${OH_IDX}).evtfifo_full"/>
          <node id="EVENT_FIFO_IS_AFULL"    mask="0x40000000" permission="r" address="0x0"
                description="Current status: Event FIFO is near-full (asserted at 75% and deasserted at 50%)"
                fw_signal="input_status_arr(${OH_IDX}).evtfifo_near_full"/>
          <node id="EVENT_FIFO_IS_EMPTY"    mask="0x80000000" permission="r" address="0x0"
                description="Current status: Event FIFO is empty"
                fw_signal="input_status_arr(${OH_IDX}).evtfifo_empty"/>
        </node>

        <node id="COUNTERS">
          <node id="CORRUPT_VFAT_BLK_CNT"  address="0x1" permission="r"
                description="This counter is incremented when a VFAT block does not
                             conform to the pattern of Axxx Cxxx Exxx... (see VFAT
                             data format)
                             Note that this data is still included in events and sent to
                             AMC13, but it does not participate in end-of-event
                             detection."
                fw_signal="input_status_arr(${OH_IDX}).cnt_corrupted_vfat"/>
          <node id="EVN"                   address="0x2" mask="0x00ffffff" permission="r"
                description="Current event number of the event builder.
                             This counter starts at 1 and increments with each
                             end-of-event detection. This number should be similar to
                             the number of events sent to AMC13 in normal operation,
                             but it might not always be exactly the same because there's
                             some latency between building an event and sending it. In
                             addition, event sending could stop due to DAQ FIFO being
                             almost full or DAQLink not being ready."
                fw_signal="input_status_arr(${OH_IDX}).eb_event_num"/>
          <node id="INPUT_FIFO_DATA_CNT"  address="0x4"  mask="0x00000fff" permission="r"
                description="Current number of words in the Input FIFO (current depth is 4096)"
                fw_signal="chamber_infifos(${OH_IDX}).data_cnt"/>
          <node id="EVT_FIFO_DATA_CNT"  address="0x4"  mask="0x0fff0000" permission="r"
                description="Current number of words in the Event FIFO (current depth is 4096)"
                fw_signal="chamber_evtfifos(${OH_IDX}).data_cnt"/>
          <node id="INPUT_FIFO_NEAR_FULL_CNT"  address="0x5"  mask="0x0000ffff" permission="r"
                description="Number of times Input FIFO was near-full (asserted at 75%, deasserted at 50%)"
                fw_signal="input_status_arr(${OH_IDX}).infifo_near_full_cnt"
                sw_monitor_warn_min_threshold="100"/>
          <node id="EVT_FIFO_NEAR_FULL_CNT"  address="0x5"  mask="0xffff0000" permission="r"
                description="Number of times Event FIFO was near-full (asserted at 75%, deasserted at 50%)"
                fw_signal="input_status_arr(${OH_IDX}).evtfifo_near_full_cnt"
                sw_monitor_warn_min_threshold="100"/>
          <node id="VFAT_BLOCK_RATE"  address="0x6"  mask="0x00007fff" permission="r"
                description="Rate of VFAT blocks (192bit words) being written to Input FIFO in Hz (multiply by 192 to get bitrate)"
                fw_signal="input_status_arr(${OH_IDX}).infifo_wr_rate"
                sw_monitor_warn_min_threshold="13000"/>
          <node id="EVT_RATE"  address="0x6"  mask="0xffff8000" permission="r"
                description="Rate of events being written to Event FIFO in Hz"
                fw_signal="input_status_arr(${OH_IDX}).evtfifo_wr_rate"/>
          <node id="MAX_EOE_TIMER"         address="0x7" mask="0x00ffffff" permission="r"
                description="Units = clock cycles @ 160MHz.
                             This indicates the maximum amount of time that event
                             builder took to build and close the event. Note: this is
                             mostly for debugging, most of the time it should be equal
                             to 'End of event timeout'"
                fw_signal="input_status_arr(${OH_IDX}).eb_max_timer"/>
          <node id="LAST_EOE_TIMER"        address="0x8" mask="0x00ffffff" permission="r"
                description="Units = clock cycles @ 160MHz.
                             This shows how long event builder took to build and close
                             the last event. Note: this is mostly for debugging, but could
                             be used to tune the 'end of event timeout'"
                fw_signal="input_status_arr(${OH_IDX}).eb_last_timer"/>
        </node>

      </node>
    </node>

    <!-- OH link module -->
    <node id="OH_LINKS"  address="0x00600000"
          description="OH Link monitoring registers"
          fw_is_module="true"
          fw_module_file="../common/hdl/oh/oh_link_regs.vhd"
          fw_user_clock_signal="clk_i"
          fw_bus_clock_signal="ipb_clk_i"
          fw_bus_reset_signal="ipb_reset_i"
          fw_master_bus_signal="ipb_mosi_i"
          fw_slave_bus_signal="ipb_miso_o"
          fw_reg_addr_msb="12"
          fw_reg_addr_lsb="0">

      <node id="OH${OH_IDX}" address="0x100"
            description="Links for OH ${OH_IDX}"
            generate="true" generate_size="12" generate_address_step="0x100" generate_idx_var="OH_IDX">

        <node id="GBT0_READY" address="0x0" mask="0x00000001" permission="r"
              description="If this is set to 1 it means that CTP7 is receiving valid GBT frames from this GBT link"
              fw_signal="gbt_link_status_arr_i(${OH_IDX} * g_NUM_GBTS_PER_OH + 0).gbt_rx_ready"
              sw_monitor_error_value="0"/>
        <node id="GBT1_READY" address="0x0" mask="0x00000002" permission="r"
              description="If this is set to 1 it means that CTP7 is receiving valid GBT frames from this GBT link"
              fw_signal="gbt_link_status_arr_i(${OH_IDX} * g_NUM_GBTS_PER_OH + 1).gbt_rx_ready"
              sw_monitor_error_value="0"/>
        <node id="GBT2_READY" address="0x0" mask="0x00000004" permission="r" gem_stations="1"
              description="If this is set to 1 it means that CTP7 is receiving valid GBT frames from this GBT link"
              fw_signal="gbt_link_status_arr_i(${OH_IDX} * g_NUM_GBTS_PER_OH + 2).gbt_rx_ready"
              sw_monitor_error_value="0"/>

        <node id="GBT0_WAS_NOT_READY" address="0x0" mask="0x00000008" permission="r"
              description="This flag is latched high whenever the GBT link ready goes low, and is reset with link reset"
              fw_signal="gbt_link_status_arr_i(${OH_IDX} * g_NUM_GBTS_PER_OH + 0).gbt_rx_had_not_ready"
              sw_monitor_warn_value="0"/>
        <node id="GBT1_WAS_NOT_READY" address="0x0" mask="0x00000010" permission="r"
              description="This flag is latched high whenever the GBT link ready goes low, and is reset with link reset"
              fw_signal="gbt_link_status_arr_i(${OH_IDX} * g_NUM_GBTS_PER_OH + 1).gbt_rx_had_not_ready"
              sw_monitor_warn_value="0"/>
        <node id="GBT2_WAS_NOT_READY" address="0x0" mask="0x00000020" permission="r" gem_stations="1"
              description="This flag is latched high whenever the GBT link ready goes low, and is reset with link reset"
              fw_signal="gbt_link_status_arr_i(${OH_IDX} * g_NUM_GBTS_PER_OH + 2).gbt_rx_had_not_ready"
              sw_monitor_warn_value="0"/>

        <node id="GBT0_RX_HAD_OVERFLOW" address="0x0" mask="0x00000040" permission="r"
              description="This flag is latched high if the GBT RX sync fifo has overflow, and is reset with link reset"
              fw_signal="gbt_link_status_arr_i(${OH_IDX} * g_NUM_GBTS_PER_OH + 0).gbt_rx_sync_status.had_ovf"
              sw_monitor_error_value="0"/>
        <node id="GBT1_RX_HAD_OVERFLOW" address="0x0" mask="0x00000080" permission="r"
              description="This flag is latched high if the GBT RX sync fifo has overflow, and is reset with link reset"
              fw_signal="gbt_link_status_arr_i(${OH_IDX} * g_NUM_GBTS_PER_OH + 1).gbt_rx_sync_status.had_ovf"
              sw_monitor_error_value="0"/>
        <node id="GBT2_RX_HAD_OVERFLOW" address="0x0" mask="0x00000100" permission="r" gem_stations="1"
              description="This flag is latched high if the GBT RX sync fifo has overflow, and is reset with link reset"
              fw_signal="gbt_link_status_arr_i(${OH_IDX} * g_NUM_GBTS_PER_OH + 2).gbt_rx_sync_status.had_ovf"
              sw_monitor_error_value="0"/>

        <node id="GBT0_RX_HAD_UNDERFLOW" address="0x0" mask="0x00000200" permission="r"
              description="This flag is latched high if the GBT RX sync fifo has underflow, and is reset with link reset"
              fw_signal="gbt_link_status_arr_i(${OH_IDX} * g_NUM_GBTS_PER_OH + 0).gbt_rx_sync_status.had_unf"
              sw_monitor_error_value="0"/>
        <node id="GBT1_RX_HAD_UNDERFLOW" address="0x0" mask="0x00000400" permission="r"
              description="This flag is latched high if the GBT RX sync fifo has underflow, and is reset with link reset"
              fw_signal="gbt_link_status_arr_i(${OH_IDX} * g_NUM_GBTS_PER_OH + 1).gbt_rx_sync_status.had_unf"
              sw_monitor_error_value="0"/>
        <node id="GBT2_RX_HAD_UNDERFLOW" address="0x0" mask="0x00000800" permission="r" gem_stations="1"
              description="This flag is latched high if the GBT RX sync fifo has underflow, and is reset with link reset"
              fw_signal="gbt_link_status_arr_i(${OH_IDX} * g_NUM_GBTS_PER_OH + 2).gbt_rx_sync_status.had_unf"
              sw_monitor_error_value="0"/>

        <node id="VFAT_MASK" address="0x1" mask="0x00ffffff" permission="rw"
              description="Mask the RX link of the selected VFATs (both slow control and DAQ path will be shut off for these VFATs)."
              fw_signal="vfat_mask_arr(${OH_IDX})" fw_default="0x000000"/>

        <node id="VFAT${VFAT_IDX}" address="0x10"
              description="Link status of VFAT ${VFAT_IDX} on ${OH_IDX}"
              generate="true" generate_size="24" generate_address_step="0x2" generate_idx_var="VFAT_IDX">

          <node id="LINK_GOOD" address="0x0" mask="0x00000001" permission="r"
                description="This flag is set high after detecting 10 consecutive good sync verify replies and set bad after 100 bad ones in a row (sync verify is done once per orbit). This flag can only go high if the initial sync procedure and RX bitslipping was done successfully"
                fw_signal="vfat3_link_status_arr_i(${OH_IDX})(${VFAT_IDX}).sync_good"
                sw_monitor_error_value="0"/>
          <node id="SYNC_ERR_CNT" address="0x0" mask="0x000000f0" permission="r"
                description="This counter counts the total number of times that VFAT3 didn't reply to sync_verify command correctly. This counter doesn't roll over, and is reset on link reset."
                fw_signal="vfat3_link_status_arr_i(${OH_IDX})(${VFAT_IDX}).sync_error_cnt"
                sw_monitor_error_value="0"/>
          <node id="DAQ_EVENT_CNT" address="0x0" mask="0x0000ff00" permission="r"
                description="This counter counts the number of DAQ events received from this VFAT (note that this is an 8bit rolling counter)"
                fw_signal="vfat3_link_status_arr_i(${OH_IDX})(${VFAT_IDX}).daq_event_cnt"/>
          <node id="DAQ_CRC_ERROR_CNT" address="0x0" mask="0x00ff0000" permission="r"
                description="This counter counts the number of CRC errors in the DAQ events received from this VFAT (note that this is an 8bit rolling counter)"
                fw_signal="vfat3_link_status_arr_i(${OH_IDX})(${VFAT_IDX}).daq_crc_err_cnt"
                sw_monitor_warn_value="100"/>

        </node>
        
      </node>
    </node>

    <!--GEM slow control module -->
    <node id="SLOW_CONTROL"  address="0x00B00000"
          description="This module is handling slow control (mainly OH SCA and OH GBTx IC related communication)"
          fw_is_module="true"
          fw_module_file="../common/hdl/slow_control/slow_control.vhd"
          fw_user_clock_signal="ttc_clk_i.clk_40"
          fw_bus_clock_signal="ipb_clk_i"
          fw_bus_reset_signal="ipb_reset_i"
          fw_master_bus_signal="ipb_mosi_i"
          fw_slave_bus_signal="ipb_miso_o"
          fw_reg_addr_msb="16"
          fw_reg_addr_lsb="0">

      <node id="SCA" address="0x0">
        <node id="CTRL" address="0x0">
          <node id="MODULE_RESET" address="0x0" permission="w"
                description="SCA controller reset (coming out of module reset it will also reset and reconfigure the SCA chip)"
                fw_write_pulse_signal="sca_reset"/>
          <node id="OH_FPGA_HARD_RESET" address="0x1" permission="w"
                description="Writing to this register will trigger OH FPGA hard reset"
                fw_write_pulse_signal="manual_hard_reset"/>
          <node id="TTC_HARD_RESET_EN" address="0x2" permission="rw"
                description="This is a bitmask (one bit per OH) that determines whether or not TTC hard reset commands are forwarded to the SCA to reset the OH FPGA (Nth bit set to 1 will enable TTC hard resets to the Nth OH)"
                fw_signal="sca_ttc_hr_enable" fw_default="0xffffffff"/>
          <node id="SCA_RESET_ENABLE_MASK" address="0x3" mask="0xffffffff" permission="rw"
                description="This bitmask defines which SCAs will be reset uppon receipt of MODULE_RESET command."
                fw_signal="sca_reset_mask" fw_default="0xffffffff"/>
        </node>

        <node id="STATUS" address="0x100">
          <node id="READY" address="0x0" mask="0xffffffff" permission="r"
                description="Bits in this register indicate that the SCA controller for the corresponding link has good communication with the SCA chip"
                fw_signal="sca_ready_arr"/>
          <node id="CRITICAL_ERROR" address="0x1" mask="0xffffffff" permission="r"
                description="Bits in this register indicate that the SCA controller for the corresponding link has encountered a critical error (needs reset)"
                fw_signal="sca_critical_error_arr"/>
          <node id="NOT_READY_CNT_OH${OH_IDX}" address="0x2" mask="0x0000ffff" permission="r" 
                description="Counts the number of times that the SCA controller READY signal went to 0 since last SCA reset"
                generate="true" generate_size="12" generate_address_step="0x00000001" generate_idx_var="OH_IDX"
                fw_signal="sca_not_ready_cnt_arr(${OH_IDX})"/>

          <!--node id="RX_ERR_CNT" address="0x1" mask="0x0000ffff" permission="r"
                description="Number of RX errors"
                fw_signal="sca_rx_err_cnt"/>
          <node id="SEQ_NUM_ERR_CNT" address="0x1" mask="0xffff0000" permission="r"
                description="Number of sequence number errors"
                fw_signal="sca_seq_num_err_cnt"/>
          <node id="CRC_ERR_CNT" address="0x2" mask="0x0000ffff" permission="r"
                description="Number of CRC errors"
                fw_signal="sca_crc_err_cnt"/>
          <node id="TRANSACTION_TIMEOUT_CNT" address="0x2" mask="0xffff0000" permission="r"
                description="Number of transaction timeouts"
                fw_signal="sca_tr_timeout_cnt"/>
          <node id="TRANSACTION_FAIL_CNT" address="0x3" mask="0x0000ffff" permission="r"
                description="Number of transaction failures (all retries used up)"
                fw_signal="sca_tr_fail_cnt"/>
          <node id="LAST_SCA_ERROR" address="0x3" mask="0x007f0000" permission="r"
                description="Last error reported by the SCA chip"
                fw_signal="sca_last_sca_error"/>
          <node id="TRANSACTION_DONE_CNT" address="0x4" permission="r"
                description="Number of transactions successfully executed"
                fw_signal="sca_tr_done_cnt"/-->
        </node>

        <node id="MANUAL_CONTROL" address="0x1000">
          <node id="LINK_ENABLE_MASK" address="0x0" mask="0xffffffff" permission="rw"
                description="This is a bitmask of enabled links for the SCA manual command.
                             Multiple channels can be enabled at the same time, which will 
                             result in a broadcast command to these channels when writing to the command registers"
                fw_signal="sca_user_command_en_mask" fw_default="0x00000000"/>
 
          <node id="SCA_CMD" address="0x1">
            <node id="SCA_CMD_CHANNEL" address="0x0" mask="0x000000ff" permission="rw"
                  description="Manual SCA command: channel"
                  fw_signal="sca_user_command.channel" fw_default="0x00"/>
            <node id="SCA_CMD_COMMAND" address="0x0" mask="0x0000ff00" permission="rw"
                  description="Manual SCA command: command"
                  fw_signal="sca_user_command.command" fw_default="0x00"/>
            <node id="SCA_CMD_LENGTH" address="0x0" mask="0x00ff0000" permission="rw"
                  description="Manual SCA command: length (range = 0 to 4)"
                  fw_signal="sca_user_command.length" fw_default="0x00"/>
            <node id="SCA_CMD_DATA" address="0x1" permission="rw"
                  description="Manual SCA command: data"
                  fw_signal="sca_user_command.data" fw_default="0x00000000"/>
            <node id="SCA_CMD_EXECUTE" address="0x2" permission="w"
                  description="Manual SCA command: writing to this register will trigger the execution of the SCA command"
                  fw_write_pulse_signal="sca_user_command_en" fw_write_done_signal="sca_user_command_done_all"/>
          </node>

          <node id="SCA_REPLY_OH${OH_IDX}" address="0x4"
                description="SCA reply for Optohybrid ${OH_IDX}"
                generate="true" generate_size="12" generate_address_step="0x00000002" generate_idx_var="OH_IDX">

            <node id="SCA_RPY_CHANNEL" address="0x0" mask="0x000000ff" permission="r"
                  description="SCA reply to the manual command: channel"
                  fw_signal="sca_user_reply_arr(${OH_IDX}).channel"/>
            <node id="SCA_RPY_ERROR" address="0x0" mask="0x0000ff00" permission="r"
                  description="SCA reply to the manual command: command"
                  fw_signal="sca_user_reply_arr(${OH_IDX}).error"/>
            <node id="SCA_RPY_LENGTH" address="0x0" mask="0x00ff0000" permission="r"
                  description="SCA reply to the manual command: length (range = 0 to 4)"
                  fw_signal="sca_user_reply_arr(${OH_IDX}).length"/>
            <node id="SCA_RPY_DATA" address="0x1" permission="r"
                  description="SCA reply to the manual command: data"
                  fw_signal="sca_user_reply_arr(${OH_IDX}).data"/>
          </node>
        </node>

        <node id="JTAG" address="0x2500">
          <node id="CTRL" address="0x0">
            <node id="ENABLE_MASK" address="0x0" mask="0xffffffff" permission="rw"
                  description="This is a bitmask of enabled links for the SCA JTAG commands.
                               Multiple channels can be enabled at the same time, which will 
                               result in a broadcast command to these channels when writing to the TDO and TMS registers"
                  fw_signal="jtag_enabled_mask" fw_default="0x00000000"/>
            <node id="SHIFT_MSB" address="0x1" mask="0x00000002" permission="rw"
                  description="If this is 1 then SCA will shift out bits MSB to LSB and if this is 0 then LSB to MSB (default)"
                  fw_signal="jtag_shift_msb_first" fw_default="0b0"/>
            <node id="EXPERT" address="0x1">
              <node id="EXEC_ON_EVERY_TDO" address="0x0" mask="0x00000004" permission="rw"
                    description="EXPERT ONLY: used to optimize firmware downloading, when set high the controller will execute
                                 JTAG_GO after every TDO shift (even if length is higher than 32)"
                    fw_signal="jtag_exec_on_every_tdo" fw_default="0b0"/>
              <node id="NO_SCA_LENGTH_UPDATE" address="0x0" mask="0x00000008" permission="rw"
                    description="EXPERT ONLY: used to optimize firmware downloading, when set high the controller will
                                 assume that SCA already has the correct length and will not update it before each JTAG_GO"
                    fw_signal="jtag_no_length_update" fw_default="0b0"/>
              <node id="SHIFT_TDO_ASYNC" address="0x0" mask="0x00000010" permission="rw"
                    description="kindof expert: if this is set high then JTAG controller will acknowledge the TDO shift
                                 command immediately, but if the second command is received while it's still busy it
                                 won't assert jtag_shift_done_o until the previous command is done"
                    fw_signal="jtag_shift_tdo_async" fw_default="0b0"/>
            </node>
          </node>
          <node id="NUM_BITS" address="0x2" mask="0x000007f" permission="rw"
                description="Number of bits in the JTAG command (0 means 128). Once you shift this number of bits of
                             TDO data, the JTAG command will be executed and TDI is available for reading"
                fw_signal="jtag_cmd_length" fw_default="0b0000000"/>
          <node id="TMS" address="0x3" permission="w"
                description="TMS bits to shift to the SCA chip. 32 bits are shifted with each write to this register.
                             The write transaction completes once the bit shifting to the SCA is already done and
                             confirmed by the SCA, so there's no need to sleep between the consecutive writes to this register."
                fw_signal="jtag_tms" fw_write_pulse_signal="jtag_shift_tms_en" fw_write_done_signal="jtag_shift_done_all"
                fw_default="0x00000000"/>
          <node id="TDO" address="0x4" permission="w"
                description="TDO bits to shift to the SCA chip. 32 bits are shifted with each write to this register.
                             Once the number of bits shifted is equal to or greater than the NUM_BITS the JTAG command
                             will be executed. The write transaction completes once the bit shifting to the SCA is
                             already done and confirmed by the SCA, so there's no need to sleep between the consecutive
                             writes to this register."
                fw_signal="jtag_tdo" fw_write_pulse_signal="jtag_shift_tdo_en" fw_write_done_signal="jtag_shift_done_all"
                fw_default="0x00000000"/>

          <node id="TDI_OH${OH_IDX}" address="0x5" permission="r"
                description="When reading this register the TDI bits are shifted from the SCA of OH${OH_IDX} (32 bits with each read)."
                generate="true" generate_size="12" generate_address_step="0x00000001" generate_idx_var="OH_IDX"
                fw_signal="jtag_tdi_arr(${OH_IDX})" fw_read_pulse_signal="jtag_shift_tdi_en_arr(${OH_IDX})" fw_read_ready_signal="jtag_shift_done_arr(${OH_IDX})"/>
        </node>

        <!--node id="DEBUG" address="0x3000">
          <node id="RAW_TX_LAST_CMD_0" address="0x0" permission="r"
                description="Last raw output on the TX, bits [31:0]"
                fw_signal="sca_tx_raw_last_cmd(31 downto 0)"/>
          <node id="RAW_TX_LAST_CMD_1" address="0x1" permission="r"
                description="Last raw output on the TX, bits [63:32]"
                fw_signal="sca_tx_raw_last_cmd(63 downto 32)"/>
          <node id="RAW_TX_LAST_CMD_2" address="0x2" permission="r"
                description="Last raw output on the TX, bits [95:64]"
                fw_signal="sca_tx_raw_last_cmd(95 downto 64)"/>
          <node id="RAW_RX_LAST_RPY_0" address="0x3" permission="r"
                description="Last raw input on the RX, bits [31:0]"
                fw_signal="sca_rx_raw_last_reply(31 downto 0)"/>
          <node id="RAW_RX_LAST_RPY_1" address="0x4" permission="r"
                description="Last raw input on the RX, bits [63:32]"
                fw_signal="sca_rx_raw_last_reply(63 downto 32)"/>
          <node id="RAW_RX_LAST_RPY_2" address="0x5" permission="r"
                description="Last raw input on the RX, bits [95:64]"
                fw_signal="sca_rx_raw_last_reply(95 downto 64)"/>
          <node id="RX_LAST_CALC_CRC" address="0x6" mask="0x0000ffff" permission="r"
                description="RX last calculated CRC"
                fw_signal="sca_rx_last_calc_crc"/>
        </node-->

      </node>

      <node id="IC" address="0x3000">
        <node id="ADDRESS" address="0x0" mask="0x0000ffff" permission="rw"
              description="GBTx register address to read or write"
              fw_signal="ic_address" fw_default="0x0000"/>
        <node id="READ_WRITE_LENGTH" address="0x1" mask="0x00000007" permission="rw"
              description="Number of data bytes to be written or read e.g. if you set it to 4 then 4 consecutive
                           GBTx registers will be written with the 4 bytes in WRITE_DATA register. Max is 4."
              fw_signal="ic_rw_length" fw_default="0x01"/>
        <node id="WRITE_DATA" address="0x2" permission="rw"
              description="GBTx register value to write"
              fw_signal="ic_write_data" fw_default="0x00"/>
        <node id="EXECUTE_WRITE" address="0x3" permission="w"
              description="writing any value here will execute a GBTx register write operation"
              fw_write_pulse_signal="ic_write_req" fw_write_done_signal="ic_write_done"/>
        <node id="EXECUTE_READ" address="0x4" permission="w"
              description="writing any value here will execute a GBTx register read operation"
              fw_write_pulse_signal="ic_read_req"/>
        <node id="GBTX_I2C_ADDR" address="0x5" mask="0x0000007f" permission="rw"
              description="GBTx I2C address as defined by the I2CADDRESS pins of the GBTx chip"
              fw_signal="ic_gbtx_i2c_addr" fw_default="0b0000001"/>
        <node id="GBTX_LINK_SELECT" address="0x6" mask="0x0000003f" permission="rw"
              description="Selects the GBT link to use"
              fw_signal="ic_link_select" fw_default="0b000000"/>
      </node>

      <node id="VFAT3" address="0x4000">
        <node id="CRC_ERROR_CNT" address="0x0" mask="0x0000ffff" permission="r"
              description="Number of CRC errors in the VFAT3 slow control reply packets"
              fw_signal="vfat3_sc_status_i.crc_error_cnt"/>
        <node id="PACKET_ERROR_CNT" address="0x0" mask="0xffff0000" permission="r"
              description="Number of packet errors in the VFAT3 slow control reply packets. Packet error means that either a received packet was too long, or a packet with good CRC was received but the contents were not as expected, more specifically one or more of the following fields were not correct: transaction ID, HDLC address, HDLC control, IPBus version, IPBus write flag."
              fw_signal="vfat3_sc_status_i.packet_error_cnt"/>
        <node id="BITSTUFFING_ERROR_CNT" address="0x1" mask="0x0000ffff" permission="r"
              description="Number of bitstuffing errors in the VFAT3 slow control reply packets. Bitstuffing error means that more than 5 SC1 characters were received in a row and it was not a frame separator (frame separator is 01111110)."
              fw_signal="vfat3_sc_status_i.bitstuff_error_cnt"/>
        <node id="TIMEOUT_ERROR_CNT" address="0x1" mask="0xffff0000" permission="r"
              description="Number of timeouts while waiting for a slow control reply from a VFAT3."
              fw_signal="vfat3_sc_status_i.timeout_error_cnt"/>
        <node id="AXI_STROBE_ERROR_CNT" address="0x2" mask="0x0000ffff" permission="r"
              description="Number of AXI strobe errors in VFAT3 slow control transactions. An AXI strobe error means that the AXI strobe went away before the VFAT3 slow control state machine replied or timed out. This might be caused by force closing the AXI transaction upstream e.g. a safety timeout in Zynq AXI master."
              fw_signal="vfat3_sc_status_i.axi_strobe_error_cnt"/>
        <node id="TRANSACTION_CNT" address="0x2" mask="0xffff0000" permission="r"
              description="Total number of VFAT3 transactions done so far. This counter rolls over."
              fw_signal="vfat3_sc_status_i.transaction_cnt"/>
      </node>

    </node>

    <!--OptoHybrid module -->
    <node id="OH"  address="0x00400000"
          description="Optohybrid Registers"
          fw_is_module="true"
          fw_is_module_external="true">

      <node id="OH${OH_IDX}"  address="0x0"
            description="Optohybrid ${OH_IDX}"
            generate="true" generate_size="12" generate_address_step="0x00010000" generate_idx_var="OH_IDX">

            <!--Insert here the OH FPGA module -->
            <xi:include href="optohybrid_registers.xml"/>

        <node id="GEB"  address="0x100000"
              description="VFAT3 registers">

            <node id="VFAT${VFAT_IDX}"  address="0x0"
                  description="VFAT ${VFAT_IDX}"
                  generate="true" generate_size="24" generate_address_step="0x00000800" generate_idx_var="VFAT_IDX">

              <node id="VFAT_CHANNELS"  address="0x0"
                    description="Registers for the individual VFAT channels
                                 Hardwired sleep value 0x00
                                 Software default value 0x00">
                <node id="CHANNEL${CHANNEL_IDX}"  address="0x00"  permission="rw"
                      description="Config register for VFAT channel ${CHANNEL_IDX}"
                      generate="true" generate_size="128" generate_address_step="0x1" generate_idx_var="CHANNEL_IDX">

                  <node id="CALPULSE_ENABLE"  address="0x0" mask="0x00008000"  permission="rw"
                        description="Enable the calibration pulse to the channel input">
                  </node>
                  <node id="MASK"  address="0x0" mask="0x00004000"  permission="rw"
                        description="Mask the channel output for trigger and readout">
                  </node>
                  <node id="ZCC_TRIM_POLARITY"  address="0x0" mask="0x00002000"  permission="rw"
                        description="Zero Crossing Comparator threshold trimming: correction polarity (0 = positive, 1 = negative)">
                  </node>
                  <node id="ZCC_TRIM_AMPLITUDE"  address="0x0" mask="0x00001f80"  permission="rw"
                        description="Zero Crossing Comparator threshold trimming: correction amplitude (steps of 0.5mV)">
                  </node>
                  <node id="ARM_TRIM_POLARITY"  address="0x0" mask="0x00000040"  permission="rw"
                        description="Arming Comparator threshold trimming: correction polarity (0 = positive, 1 = negative)">
                  </node>
                  <node id="ARM_TRIM_AMPLITUDE"  address="0x0" mask="0x0000003f"  permission="rw"
                        description="Arming Comparator threshold trimming: correction amplitude (steps of 0.5mV)">
                  </node>
                  
                </node>
              </node> <!-- end of VFATChannels -->

              <!-- a catch-all for all config registers (individual bits are extracted below), may want to use these registers for faster configuration to set all 32 bits at once instead of individual pieces -->
              <node id="CFG_${CFG_REG_IDX}"  address="0x81"  permission="rw"
                    description="VFAT control register number ${CFG_REG_IDX}"
                    generate="true" generate_size="17" generate_address_step="0x1" generate_idx_var="CFG_REG_IDX">
              </node>
              <!-- -->

              <node id="CFG_PULSE_STRETCH"  address="0x81" mask="0x0000e000"  permission="rw"
                    description="Pulse Stretcher control. Range is from 1 to 8 clock cycles (0 means 1 cycle, 7 means 8 cycles)">
              </node>
              <node id="CFG_SYNC_LEVEL_MODE"  address="0x81" mask="0x00000004"  permission="rw"
                    description="Switch the input synchronizer from edge to level mode (0 = edge, 1 = level)">
              </node>
              <node id="CFG_SELF_TRIGGER_MODE"  address="0x81" mask="0x00000002"  permission="rw"
                    description="Enable self trigger mode (0 = disable, 1 = enable)">
              </node>
              <node id="CFG_DDR_TRIGGER_MODE"  address="0x81" mask="0x00000001"  permission="rw"
                    description="Enable DDR trigger output mode (0 = SDR, 1 = DDR)">
              </node>

              <node id="CFG_SPZS_SUMMARY_ONLY"  address="0x82" mask="0x00008000"  permission="rw"
                    description="When set high, the SPZS mode will send only the 16bit partition summary (no sub-partition data at all)">
              </node>
              <node id="CFG_SPZS_MAX_PARTITIONS"  address="0x82" mask="0x00003c00"  permission="rw"
                    description="Maximum number of sub-partition data to send in SPZS mode (range: 1-16)">
              </node>
              <node id="CFG_SPZS_ENABLE"  address="0x82" mask="0x00000100"  permission="rw"
                    description="Enable SPZS zero suppression mode">
              </node>
              <node id="CFG_SZP_ENABLE"  address="0x82" mask="0x00000080"  permission="rw"
                    description="Enable SZP zero suppression mode (suppress zero packets -- only send the header)">
              </node>
              <node id="CFG_SZD_ENABLE"  address="0x82" mask="0x00000040"  permission="rw"
                    description="Enable SZD zero suppression mode (suppress zero data only -- still send header, EC, BC and CRC)">
              </node>
              <node id="CFG_TIME_TAG"  address="0x82" mask="0x00000030"  permission="rw"
                    description="Time tag format (00 = EC and BC, 01 = EC, 10 = BC, 11 = EC+BC)">
              </node>
              <node id="CFG_EC_BYTES"  address="0x82" mask="0x00000006"  permission="rw"
                    description="Event counter bytes (00 = 1B, 01 = 2B, 10 = 3B, 11 = 1B)">
              </node>
              <node id="CFG_BC_BYTES"  address="0x82" mask="0x00000001"  permission="rw"
                    description="Bunch counter bytes (0 = 2B, 1 = 3B)">
              </node>
              <node id="CFG_FP_FE"  address="0x83" mask="0x000000e0"  permission="rw"
                    description="Front end peaking time (000 = 25ns, 001 = 50ns, 011 = 75ns, 111 = 100ns)">
              </node>
              <node id="CFG_RES_PRE"  address="0x83" mask="0x0000001c"  permission="rw"
                    description="Preamplifier resistance set (001 = high gain, 010 = middle gain, 100 = low gain)">
              </node>
              <node id="CFG_CAP_PRE"  address="0x83" mask="0x00000003"  permission="rw"
                    description="Preamplifier capacity set (00 = high gain, 01 = middle gain, 11 = low gain)">
              </node>
              <node id="CFG_PT"  address="0x84" mask="0x000003c0"  permission="rw"
                    description="CFD Time Constant (0001 = 25ns, 0011 = 50ns, 0111 = 75ns, 1111 = 100ns)">
              </node>
              <node id="CFG_EN_HYST"  address="0x84" mask="0x00000020"  permission="rw"
                    description="Arming comparator hysteresis (0 = disable, 1 = enable)">
              </node>
              <node id="CFG_SEL_POL"  address="0x84" mask="0x00000010"  permission="rw"
                    description="CFD input charge polarity (0 = positive, 1 = negative/GEM )">
              </node>
              <node id="CFG_FORCE_EN_ZCC"  address="0x84" mask="0x00000008"  permission="rw"
                    description="Debug and calibration: force ZCC output, independent from arming comp (0 = disable, 1 = enable)">
              </node>
              <node id="CFG_FORCE_TH"  address="0x84" mask="0x00000004"  permission="rw"
                    description="Debug: force active ZCC threshold (0 = disable, 1 = enable)">
              </node>
              <node id="CFG_SEL_COMP_MODE"  address="0x84" mask="0x00000003"  permission="rw"
                    description="CFD output mode (00 = normal, 01 = arming, 10 = ZCC, 11 = 0)">
              </node>
              <node id="CFG_VREF_ADC"  address="0x85" mask="0x00000300"  permission="rw"
                    description="ADC internal reference tuning, 50mV steps to adjust to 1.0V during production calibration (range: 0-3)">
              </node>
              <node id="CFG_MON_GAIN"  address="0x85" mask="0x00000080"  permission="rw"
                    description="Gain of ADC monitoring buffer (0 = gain 1, 1 = gain 5)">
              </node>
              <node id="CFG_MONITOR_SELECT"  address="0x85" mask="0x0000003f"  permission="rw"
                    description="Monitoring selection (0 = Imon Iref, 1 = Imon Calib IDC, 2 = Imon Preamp InpTran, 3 = Imon Preamp LC, 4 = Imon Preamp SF, 5 = Imon Shap FC, 6 = Imon Shap Inpair, 7 = Imon SD Inpair, 8 = Imon SD FC, 9 = Imon SD SF, 10 = Imon CFD Bias1, 11 = Imon CFD Bias2, 12 = Imon CFD Hyst, 13 = Imon CFD Ireflocal, 14 = Imon CFD ThArm, 15 = Imon CFD ThZcc, 16 = Imon SLVS Ibias, 32 = Vmon BGR, 33 = Vmon Calib Vstep, 34 = Vmon Preamp Vref, 35 = Vmon Vth Arm, 36 = Vmon Vth ZCC, 37 = V Tsens Int, 38 = V Tsens Ext, 39 = ADC ref, 40 = ADC VinM, 41 = SLVS Vref">
              </node>
              <node id="CFG_IREF"  address="0x86" mask="0x0000003f"  permission="rw"
                    description="Tuning of global reference current generated by Bandgap reference circuit. Target value: 10uA. Nominal: 310nA/bit">
              </node>

              <node id="CFG_THR_ZCC_DAC"  address="0x87" mask="0x0000ff00" permission="rw"
                    description="ZCC global threshold: nominal 0.5mV/bit (range: 0x00-0xff)">
              </node>
              <node id="CFG_THR_ARM_DAC"  address="0x87" mask="0x000000ff" permission="rw"
                    description="Arming global threshold: nominal 2mV/bit (range: 0x00-0xff)">
              </node>

              <node id="CFG_HYST"  address="0x88" mask="0x0000003f" permission="rw"
                    description="Global hysteresis DAC: nominal 0.4mV/bit (range: 0x00-0x3f)">
              </node>

              <node id="CFG_LATENCY"  address="0x89" mask="0x0000ffff" permission="rw"
                    description="Internal L1A latency (range: 0-1023)">
              </node>

              <node id="CFG_CAL_SEL_POL"  address="0x8a" mask="0x00004000" permission="rw"
                    description="Calibration pulse polarity (0 = positive, 1 = negative)">
              </node>
              <node id="CFG_CAL_PHI"  address="0x8a" mask="0x00003800" permission="rw"
                    description="Pulse phase in 1/320MHz (3.125ns) delay (range: 0-7, where 0 = no delay and 7 = 21.87ns)">
              </node>
              <node id="CFG_CAL_EXT"  address="0x8a" mask="0x00000400" permission="rw"
                    description="External analog voltage step (0 = disable, 1 = enable)">
              </node>
              <node id="CFG_CAL_DAC"  address="0x8a" mask="0x000003fc" permission="rw"
                    description="CAL DAC: amplitude of current pulse. 256-CAL DAC: amplitude of voltage step. Range: 0-255">
              </node>
              <node id="CFG_CAL_MODE"  address="0x8a" mask="0x00000003" permission="rw"
                    description="Cal pulse mode (00 = disabled, 01 = voltage pulse, 1x = current pulse">
              </node>
              <node id="CFG_CAL_FS"  address="0x8b" mask="0x00000600" permission="rw"
                    description="Cal current pulse scale factor. Q = CAL DUR[s] * CAL DAC * 10nA * CAL FS[%] (00 = 25%, 01 = 50%, 10 = 75%, 11 = 100%)">
              </node>
              <node id="CFG_CAL_DUR"  address="0x8b" mask="0x000001ff" permission="rw"
                    description="Cal pulse duration in 40MHz clock cycles (range: 0-0x1ff)">
              </node>

              <node id="CFG_BIAS_CFD_DAC_2"  address="0x8c" mask="0x00000fc0" permission="rw"
                    description="CFD Bias 2 (current). Range: 0-0x3f (default = 0x28)">
              </node>
              <node id="CFG_BIAS_CFD_DAC_1"  address="0x8c" mask="0x0000003f" permission="rw"
                    description="CFD Bias 1 (current). Range: 0-0x3f (default = 0x28)">
              </node>
              <node id="CFG_BIAS_PRE_I_BSF"  address="0x8d" mask="0x00003f00" permission="rw"
                    description="Preamplifier bias source follower (current). Range: 0-0x3f (default = 1 = 2uA)">
              </node>
              <node id="CFG_BIAS_PRE_I_BIT"  address="0x8d" mask="0x000000ff" permission="rw"
                    description="Preamplifier bias input transistor (current). Range: 0-0xff (default = 1 = 1uA)">
              </node>
              <node id="CFG_BIAS_PRE_I_BLCC"  address="0x8e" mask="0x00003f00" permission="rw"
                    description="Preamplifier bias leakage compensation (current). Range: 0-0x3f (default = 15 = 15nA)">
              </node>
              <node id="CFG_BIAS_PRE_VREF"  address="0x8e" mask="0x000000ff" permission="rw"
                    description="Preamplifier VREF. Range: 0-0xff (default = 86 = 430mV)">
              </node>
              <node id="CFG_BIAS_SH_I_BFCAS"  address="0x8f" mask="0x0000ff00" permission="rw"
                    description="Shaper folded cascode (current). Range: 0-0xff (default = 1 = 100nA)">
              </node>
              <node id="CFG_BIAS_SH_I_BDIFF"  address="0x8f" mask="0x000000ff" permission="rw"
                    description="Shaper input pair (current). Range: 0-0xff (default = 1 = 100nA)">
              </node>
              <node id="CFG_BIAS_SH_I_BFAMP"  address="0x90" mask="0x00003f00" permission="rw"
                    description="Shaper feed amplifier (current). Range: 0-0x3f (default = 1 = 1nA)">
              </node>
              <node id="CFG_BIAS_SD_I_BDIFF"  address="0x90" mask="0x000000ff" permission="rw"
                    description="SD input pair (current). Range: 0-0xff (default = 1 = 100nA)">
              </node>
              <node id="CFG_BIAS_SD_I_BSF"  address="0x91" mask="0x00003f00" permission="rw"
                    description="SD source follower (current). Range: 0-0x3f (default = 1 = 2uA)">
              </node>
              <node id="CFG_BIAS_SD_I_BFCAS"  address="0x91" mask="0x000000ff" permission="rw"
                    description="SD folded cascode (current). Range: 0-0xff (default = 1 = 100nA)">
              </node>

              <node id="CFG_RUN" address="0x300" mask="0x00000001" permission="rw"
                    description="SLEEP/RUN mode (0 = SLEEP, 1 = RUN)">
              </node>

              <node id="HW_ID"  address="0x100"  permission="r"
                    description="Device hardware ID register. Reports 0x56464154 (ASCII 'VFAT') on read.">
              </node>
              <node id="HW_ID_VER"  address="0x101"  permission="r"
                    description="Hardware version. Reports 0x00030000 (v3.0.0) on read.">
              </node>
              <node id="TEST_REG"  address="0x102"  permission="rw"
                    description="General purpose read/write register.">
              </node>
              <node id="HW_CHIP_ID"  address="0x103"  permission="r"
                    description="Chip ID from eFuses.">
              </node>
              
              <!-- probably better to leave these out as they should only be used during fusing
              <node id="HW_PROG_TIME"  address="0x104" mask="0x0007ff00" permission="w"
                    description="eFuse: program time in 25ns units. Range: 0-0x7ff">
              </node>
              <node id="HW_PROG_BIT_ADDR"  address="0x104" mask="0x0000001f" permission="w"
                    description="eFuse: address of the bit to be programmed. Range: 0-0x1f">
              </node>
              -->

              <node id="ADC0_CACHED"  address="0x280" mask="0x000003ff" permission="r"
                    description="Primary ADC read (using the internal reference). Note, this value is returned from CTP7's cache (last known value of ADC0 for this VFAT since ADC0_UPDATE was called). To update the cache, read or write ADC0_UPDATE, and wait at least 20us before reading this register to take the updated value (note that value of 0 indicates a read error)">
              </node>
              <node id="ADC0_UPDATE"  address="0x200" mask="0x00000001" permission="rw"
                    description="Reading or writing this register will trigger a read of the ADC0 value form this VFAT and update of the cache. The read from the VFAT takes aroun 11us, so it's advised to wait for 20us to be sure that the cache was already updated before reading ADC0_CACHED">
              </node>

              <node id="ADC1_CACHED"  address="0x281" mask="0x000003ff" permission="r"
                    description="ADC1 read (using the external reference). Note, this value is returned from CTP7's cache. To update the cache, read or write ADC1_UPDATE, and wait at least 20us before reading this register to take the updated value (note that value of 0 indicates a read error)">
              </node>
              <node id="ADC1_UPDATE"  address="0x201" mask="0x00000001" permission="rw"
                    description="Reading or writing this register will trigger a read of the ADC1 value form this VFAT and update of the cache. The read from the VFAT takes aroun 11us, so it's advised to wait for 20us to be sure that the cache was already updated before reading ADC1_CACHED">
              </node>


            </node>
        </node>

      </node> <!-- end OH${OH_IDX} block -->
    </node> <!-- end OptoHybrid block -->

    <!--Config Blaster module -->
    <node id="CONFIG_BLASTER"  address="0x00c00000"
          description="Configuration Blaster. This module stores configuration data for all GBTXs, VFAT3s, and OH FPGAs, and then streams this configuration data to each device after a hard-reset."
          fw_is_module="true"
          fw_is_module_external="true">

      <node id="CTRL" address="0x0">
        <node id="BLASTER_ENABLE" address="0x0" mask="0x00000001" permission="rw"
              description="Set this to 1 to enable the configuration blasting after the hard reset. By default this is disabled, because config RAM is empty on startup, so only enable this after the config RAM has been written with valid config data.">
        </node>
      </node>        

      <node id="STATUS" address="0x100">
        <node id="GBT_RAM_SIZE" address="0x0" permission="r" description="Size of the GBT config RAM (in 32bit words, or number of available addresses)"/>
        <node id="VFAT_RAM_SIZE" address="0x1" permission="r" description="Size of the VFAT config RAM (in 32bit words, or number of available addresses)"/>
        <node id="OH_RAM_SIZE" address="0x2" permission="r" description="Size of the OH config RAM (in 32bit words, or number of available addresses)"/>
      </node>        

      <node id="RAM" address="0x10000">
        <node id="GBT" address="0x00000" mode="block" size="3312" permission="rw"
              description="Configuration RAM for GBTX chips. Each GBTX has 366 x 8bit registers, and each address in this RAM holds 4 register values in LSB format (so in total there are 92 RAM addresses for each chip, where the last one is only partially filled).
                           The actual RAM in the firmware is sized according to the number of OH links present in the firmware, so software should check how many OHs are supported by the firmware and only fill out the corresponding number of configuration entries.
                           RAM size is also provided in the STATUS registers of this module.
                           If the software attempts to write outside the bounds of the RAM, it may be overwriting other data."/>
        <node id="VFAT" address="0x10000" mode="block" size="21312" permission="rw"
              description="Configuration RAM for VFAT chips. Each VFAT has 147 x 16bit registers, and each address in this RAM holds 2 register values in LSB format (so in total there are 74 RAM addresses for each chip, where the last one is only partially filled).
                           The actual RAM in the firmware is sized according to the number of OH links present in the firmware, so software should check how many OHs are supported by the firmware and only fill out the corresponding number of configuration entries.
                           RAM size is also provided in the STATUS registers of this module.
                           If the software attempts to write outside the bounds of the RAM, it may be overwriting other data."/>

        <node id="OH_FPGA" address="0x20000" mode="block" size="2400" permission="rw"
              description="Configuration RAM for OH FPGAs. 100 32bit registers are allocated for each OH at the moment. For each register, a 32bit OH register address (local to OH address space) has to be written to this RAM, followed by a 32bit register value.
                           The actual RAM in the firmware is sized according to the number of OH links present in the firmware, so software should check how many OHs are supported by the firmware and only fill out the corresponding number of configuration entries.
                           RAM size is also provided in the STATUS registers of this module.
                           If the software attempts to write outside the bounds of the RAM, it may be overwriting other data."/>
        <node id="GBT_OH${OH_IDX}"  address="0x00000" mode="block" size="276" permission="rw"
              description="GBTX configuration RAM pointer to OH${OH_IDX}. This part of the RAM contains configuration of all 3 GBTXs for this OH."
	      generate="true" generate_size="12" generate_address_step="0x144" generate_idx_var="OH_IDX"/>
        <node id="VFAT_OH${OH_IDX}"  address="0x10000" mode="block" size="1776" permission="rw"
              description="VFAT configuration RAM pointer to OH#${OH_IDX}. This part of the RAM contains configuration of all 24 VFATs for this OH."
	      generate="true" generate_size="12" generate_address_step="0x6f0" generate_idx_var="OH_IDX"/>
        <node id="OH_FPGA_OH${OH_IDX}"  address="0x20000" mode="block" size="200" permission="rw"
              description="OH FPGA configuration RAM pointer to OH#${OH_IDX}."
	      generate="true" generate_size="12" generate_address_step="0xc8" generate_idx_var="OH_IDX"/>
      </node>

    </node> <!-- end Config Blaster block -->

    <!-- Optical links module -->
    <node id="OPTICAL_LINKS"  address="0x1400000"
          description="This module contains counters and control registers of all the optical links on the board (regardless of link rate or what they connect to)"
          fw_is_module="true"
          fw_is_module_external="true">

      <node id="MGT_CHANNEL_${MGT}" address="0x0"
            description="MGT channel ${MGT} control and status. Note: these are MGT channles, which do not correspond 1-to-1 with the fiber numbering. Please refer here for MGT channel to fiber mapping: https://docs.google.com/spreadsheets/d/1-AE7GeeU10GfLB-9FYOMN4k0-Z7bVkiQpLfXC4G2irI"
            generate="true" generate_size="64" generate_address_step="0x00000040" generate_idx_var="MGT">

        <node id="RESET" address="0x1" permission="rw"
              description="Writing 1 to bit 0 will trigger MGT TX channel reset, and writing 1 to bit 1 will trigger the MGT RX channel reset (write 3 to trigger both)">
          <node id="TX_RESET" address="0x0" mask="0x00000001" permission="rw"
                description="Writing 1 to this reg will trigger MGT TX channel reset"/>
          <node id="RX_RESET" address="0x0" mask="0x00000002" permission="rw"
                description="Writing 1 to this reg will trigger MGT RX channel reset"/>
          <node id="CPLL_RESET" address="0x0" mask="0x00000004" permission="rw"
                description="Writing 1 to this reg will trigger MGT CPLL reset"/>
        </node>

        <node id="CTRL" address="0x2" permission="rw"
              description="This register exposes multiple MGT controls: bit 0 -- TX powerdown, bit 1 -- RX powerdown, bit 2 -- TX polarity, bit 3 -- RX polarity, bit 4 -- loopback, bit 5 -- TX inhibit, bit 6 -- RX low power mode enable">
          <node id="TX_POWERDOWN" address="0x0" mask="0x00000001" permission="rw"
                description="Setting this to 1 will powerdown the TX (writes 11 to TXPD), and 0 will put it in normal power mode (writes 00 to TXPD)"/>
          <node id="RX_POWERDOWN" address="0x0" mask="0x00000002" permission="rw"
                description="Setting this to 1 will powerdown the RX (writes 11 to RXPD), and 0 will put it in normal power mode (writes 00 to RXPD)"/>
          <node id="TX_POLARITY" address="0x0" mask="0x00000004" permission="rw"
                description="Setting this to 1 will invert the polarity of TX, setting to 0 will result in normal TX polarity"/>
          <node id="RX_POLARITY" address="0x0" mask="0x00000008" permission="rw"
                description="Setting this to 1 will invert the polarity of RX, setting to 0 will result in normal RX polarity"/>
          <node id="LOOPBACK" address="0x0" mask="0x00000010" permission="rw"
                description="Setting this to 1 will enable the near-end PMA loopback of the MGT (sets MGT LOOPBACK port to 010). This is an expert debug feature."/>
          <node id="TX_INHIBIT" address="0x0" mask="0x00000020" permission="rw"
                description="Setting this to 1 will inhibit the TX channel (forces MGTHTXP to 0 and MGTHTXN to 1). This is an expert debug feature."/>
          <node id="RX_LOW_POWER_MODE" address="0x0" mask="0x00000040" permission="rw"
                description="Setting this to 1 enables the RX LPM (this controls RXLPMEN). NOTE: THIS MUST ALWAYS BE SET TO 1 FOR GOOD RX PERFORMANCE WITH 8b10b ENCODING."/>
          <node id="RX_PRBS_SEL" address="0x1" mask="0x00000007" permission="rw"
                description="Controls the RX PRBS mode: 000 -- normal operation (no PRBS checks), 001 -- PRBS7, 010 -- PRBS15, 011 -- PRBS23, 100 -- PRBS31"/>
          <node id="TX_PRBS_SEL" address="0x1" mask="0x00000070" permission="rw"
                description="Controls the TX PRBS mode: 000 -- normal operation (no PRBS), 001 -- PRBS7, 010 -- PRBS15, 011 -- PRBS23, 100 -- PRBS31, 101 -- PCIe compliance patteren, 110 -- square wave with 2 UI (alternating 0s and 1s), 111 -- square wave with 16 UI, 20 UI, 32 UI or 40 UI period depending on data width"/>
          <node id="PRBS_CNT_RESET" address="0x2" mask="0x00000001" permission="w"
                description="Writing 1 here resets the PRBS error counters"/>
          <node id="RX_ERROR_CNT_RESET" address="0x3" mask="0x00000001" permission="w"
                description="Writing 1 here resets the RX error counters for this channel (not in table and disperr)"/>
        </node>

        <node id="STATUS" address="0x0" permission="r">
          <node id="TX_RESET_DONE" address="0x0" mask="0x00000001" permission="r"
                description="TX reset done signal"/>
          <node id="RX_RESET_DONE" address="0x0" mask="0x00000002" permission="r"
                description="RX reset done signal"/>
          <node id="CPLL_LOCKED" address="0x0" mask="0x00000004" permission="r"
                description="CPLL locked signal"/>
          <node id="CPLL_REF_CLK_LOST" address="0x0" mask="0x00000008" permission="r"
                description="CPLL reference clock is lost if this is 1"/>
          <node id="PRBS_ERROR_CNT" address="0x4" permission="r"
                description="PRBS error counter"/>
          <node id="PRBS_ERROR_CNT" address="0x4" permission="r"
                description="PRBS error counter"/>
          <node id="RX_NOT_IN_TABLE_CNT" address="0x5" permission="r"
                description="RX not-in-table counter"/>
          <node id="RX_DISPERR_CNT" address="0x6" permission="r"
                description="RX disparity error counter"/>
        </node>

      </node>

    </node> <!--End of optical links module -->

  </node>
